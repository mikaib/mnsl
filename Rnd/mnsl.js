// Generated by Haxe 4.3.3
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var Demo = function() { };
Demo.__name__ = true;
Demo.main = function() {
	window.compile = Demo.compile;
};
Demo.compile = function(code,optimize) {
	var shader;
	if(optimize) {
		shader = mnsl_MNSL.fromSource(code,new mnsl_MNSLContextOptions(null,null,null,null,null));
	} else {
		shader = mnsl_MNSL.fromSource(code,new mnsl_MNSLContextOptions(null,null,[],null,null));
	}
	if(shader.hasErrors()) {
		throw haxe_Exception.thrown(shader.errorToString(shader.getErrors()[0]));
	}
	var glsl = shader.emitGLSL(new mnsl_glsl_MNSLGLSLConfig(300,"es",null,null));
	return glsl;
};
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.now = function() {
	return Date.now();
};
var Lambda = function() { };
Lambda.__name__ = true;
Lambda.count = function(it,pred) {
	var n = 0;
	if(pred == null) {
		var _ = $getIterator(it);
		while(_.hasNext()) {
			var _1 = _.next();
			++n;
		}
	} else {
		var x = $getIterator(it);
		while(x.hasNext()) {
			var x1 = x.next();
			if(pred(x1)) {
				++n;
			}
		}
	}
	return n;
};
Math.__name__ = true;
var Reflect = function() { };
Reflect.__name__ = true;
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( _g ) {
		return null;
	}
};
Reflect.isFunction = function(f) {
	if(typeof(f) == "function") {
		return !(f.__name__ || f.__ename__);
	} else {
		return false;
	}
};
Reflect.compare = function(a,b) {
	if(a == b) {
		return 0;
	} else if(a > b) {
		return 1;
	} else {
		return -1;
	}
};
Reflect.isEnumValue = function(v) {
	if(v != null) {
		return v.__enum__ != null;
	} else {
		return false;
	}
};
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	var v = parseInt(x);
	if(isNaN(v)) {
		return null;
	}
	return v;
};
var StringTools = function() { };
StringTools.__name__ = true;
StringTools.startsWith = function(s,start) {
	if(s.length >= start.length) {
		return s.lastIndexOf(start,0) == 0;
	} else {
		return false;
	}
};
StringTools.endsWith = function(s,end) {
	var elen = end.length;
	var slen = s.length;
	if(slen >= elen) {
		return s.indexOf(end,slen - elen) == slen - elen;
	} else {
		return false;
	}
};
StringTools.lpad = function(s,c,l) {
	if(c.length <= 0) {
		return s;
	}
	var buf_b = "";
	l -= s.length;
	while(buf_b.length < l) buf_b += c == null ? "null" : "" + c;
	buf_b += s == null ? "null" : "" + s;
	return buf_b;
};
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
var Type = function() { };
Type.__name__ = true;
Type.getEnum = function(o) {
	if(o == null) {
		return null;
	}
	return $hxEnums[o.__enum__];
};
Type.createEnum = function(e,constr,params) {
	var f = Reflect.field(e,constr);
	if(f == null) {
		throw haxe_Exception.thrown("No such constructor " + constr);
	}
	if(Reflect.isFunction(f)) {
		if(params == null) {
			throw haxe_Exception.thrown("Constructor " + constr + " need parameters");
		}
		return f.apply(e,params);
	}
	if(params != null && params.length != 0) {
		throw haxe_Exception.thrown("Constructor " + constr + " does not need parameters");
	}
	return f;
};
Type.enumEq = function(a,b) {
	if(a == b) {
		return true;
	}
	try {
		var e = a.__enum__;
		if(e == null || e != b.__enum__) {
			return false;
		}
		if(a._hx_index != b._hx_index) {
			return false;
		}
		var enm = $hxEnums[e];
		var params = enm.__constructs__[a._hx_index].__params__;
		var _g = 0;
		while(_g < params.length) {
			var f = params[_g];
			++_g;
			if(!Type.enumEq(a[f],b[f])) {
				return false;
			}
		}
	} catch( _g ) {
		return false;
	}
	return true;
};
Type.enumParameters = function(e) {
	var enm = $hxEnums[e.__enum__];
	var params = enm.__constructs__[e._hx_index].__params__;
	if(params != null) {
		var _g = [];
		var _g1 = 0;
		while(_g1 < params.length) {
			var p = params[_g1];
			++_g1;
			_g.push(e[p]);
		}
		return _g;
	} else {
		return [];
	}
};
var haxe_IMap = function() { };
haxe_IMap.__name__ = true;
haxe_IMap.__isInterface__ = true;
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
};
haxe_Exception.__name__ = true;
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	toString: function() {
		return this.get_message();
	}
	,get_message: function() {
		return this.message;
	}
	,get_native: function() {
		return this.__nativeException;
	}
	,__class__: haxe_Exception
});
var haxe_Log = function() { };
haxe_Log.__name__ = true;
haxe_Log.formatOutput = function(v,infos) {
	var str = Std.string(v);
	if(infos == null) {
		return str;
	}
	var pstr = infos.fileName + ":" + infos.lineNumber;
	if(infos.customParams != null) {
		var _g = 0;
		var _g1 = infos.customParams;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			str += ", " + Std.string(v);
		}
	}
	return pstr + ": " + str;
};
haxe_Log.trace = function(v,infos) {
	var str = haxe_Log.formatOutput(v,infos);
	if(typeof(console) != "undefined" && console.log != null) {
		console.log(str);
	}
};
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
};
haxe_ValueException.__name__ = true;
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
	__class__: haxe_ValueException
});
var haxe_ds_BalancedTree = function() {
};
haxe_ds_BalancedTree.__name__ = true;
haxe_ds_BalancedTree.__interfaces__ = [haxe_IMap];
haxe_ds_BalancedTree.prototype = {
	set: function(key,value) {
		this.root = this.setLoop(key,value,this.root);
	}
	,get: function(key) {
		var node = this.root;
		while(node != null) {
			var c = this.compare(key,node.key);
			if(c == 0) {
				return node.value;
			}
			if(c < 0) {
				node = node.left;
			} else {
				node = node.right;
			}
		}
		return null;
	}
	,setLoop: function(k,v,node) {
		if(node == null) {
			return new haxe_ds_TreeNode(null,k,v,null);
		}
		var c = this.compare(k,node.key);
		if(c == 0) {
			return new haxe_ds_TreeNode(node.left,k,v,node.right,node == null ? 0 : node._height);
		} else if(c < 0) {
			var nl = this.setLoop(k,v,node.left);
			return this.balance(nl,node.key,node.value,node.right);
		} else {
			var nr = this.setLoop(k,v,node.right);
			return this.balance(node.left,node.key,node.value,nr);
		}
	}
	,balance: function(l,k,v,r) {
		var hl = l == null ? 0 : l._height;
		var hr = r == null ? 0 : r._height;
		if(hl > hr + 2) {
			var _this = l.left;
			var _this1 = l.right;
			if((_this == null ? 0 : _this._height) >= (_this1 == null ? 0 : _this1._height)) {
				return new haxe_ds_TreeNode(l.left,l.key,l.value,new haxe_ds_TreeNode(l.right,k,v,r));
			} else {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l.left,l.key,l.value,l.right.left),l.right.key,l.right.value,new haxe_ds_TreeNode(l.right.right,k,v,r));
			}
		} else if(hr > hl + 2) {
			var _this = r.right;
			var _this1 = r.left;
			if((_this == null ? 0 : _this._height) > (_this1 == null ? 0 : _this1._height)) {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l,k,v,r.left),r.key,r.value,r.right);
			} else {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l,k,v,r.left.left),r.left.key,r.left.value,new haxe_ds_TreeNode(r.left.right,r.key,r.value,r.right));
			}
		} else {
			return new haxe_ds_TreeNode(l,k,v,r,(hl > hr ? hl : hr) + 1);
		}
	}
	,compare: function(k1,k2) {
		return Reflect.compare(k1,k2);
	}
	,__class__: haxe_ds_BalancedTree
};
var haxe_ds_TreeNode = function(l,k,v,r,h) {
	if(h == null) {
		h = -1;
	}
	this.left = l;
	this.key = k;
	this.value = v;
	this.right = r;
	if(h == -1) {
		var tmp;
		var _this = this.left;
		var _this1 = this.right;
		if((_this == null ? 0 : _this._height) > (_this1 == null ? 0 : _this1._height)) {
			var _this = this.left;
			tmp = _this == null ? 0 : _this._height;
		} else {
			var _this = this.right;
			tmp = _this == null ? 0 : _this._height;
		}
		this._height = tmp + 1;
	} else {
		this._height = h;
	}
};
haxe_ds_TreeNode.__name__ = true;
haxe_ds_TreeNode.prototype = {
	__class__: haxe_ds_TreeNode
};
var haxe_ds_EnumValueMap = function() {
	haxe_ds_BalancedTree.call(this);
};
haxe_ds_EnumValueMap.__name__ = true;
haxe_ds_EnumValueMap.__interfaces__ = [haxe_IMap];
haxe_ds_EnumValueMap.__super__ = haxe_ds_BalancedTree;
haxe_ds_EnumValueMap.prototype = $extend(haxe_ds_BalancedTree.prototype,{
	compare: function(k1,k2) {
		var d = k1._hx_index - k2._hx_index;
		if(d != 0) {
			return d;
		}
		var p1 = Type.enumParameters(k1);
		var p2 = Type.enumParameters(k2);
		if(p1.length == 0 && p2.length == 0) {
			return 0;
		}
		return this.compareArgs(p1,p2);
	}
	,compareArgs: function(a1,a2) {
		var ld = a1.length - a2.length;
		if(ld != 0) {
			return ld;
		}
		var _g = 0;
		var _g1 = a1.length;
		while(_g < _g1) {
			var i = _g++;
			var d = this.compareArg(a1[i],a2[i]);
			if(d != 0) {
				return d;
			}
		}
		return 0;
	}
	,compareArg: function(v1,v2) {
		if(Reflect.isEnumValue(v1) && Reflect.isEnumValue(v2)) {
			return this.compare(v1,v2);
		} else if(((v1) instanceof Array) && ((v2) instanceof Array)) {
			return this.compareArgs(v1,v2);
		} else {
			return Reflect.compare(v1,v2);
		}
	}
	,__class__: haxe_ds_EnumValueMap
});
var haxe_ds_IntMap = function() {
	this.h = { };
};
haxe_ds_IntMap.__name__ = true;
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
haxe_ds_IntMap.prototype = {
	remove: function(key) {
		if(!this.h.hasOwnProperty(key)) {
			return false;
		}
		delete(this.h[key]);
		return true;
	}
	,keys: function() {
		var a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) a.push(+key);
		return new haxe_iterators_ArrayIterator(a);
	}
	,iterator: function() {
		return { ref : this.h, it : this.keys(), hasNext : function() {
			return this.it.hasNext();
		}, next : function() {
			var i = this.it.next();
			return this.ref[i];
		}};
	}
	,copy: function() {
		var copied = new haxe_ds_IntMap();
		var key = this.keys();
		while(key.hasNext()) {
			var key1 = key.next();
			copied.h[key1] = this.h[key1];
		}
		return copied;
	}
	,__class__: haxe_ds_IntMap
};
var haxe_ds_ObjectMap = function() {
	this.h = { __keys__ : { }};
};
haxe_ds_ObjectMap.__name__ = true;
haxe_ds_ObjectMap.__interfaces__ = [haxe_IMap];
haxe_ds_ObjectMap.prototype = {
	set: function(key,value) {
		var id = key.__id__;
		if(id == null) {
			id = (key.__id__ = $global.$haxeUID++);
		}
		this.h[id] = value;
		this.h.__keys__[id] = key;
	}
	,keys: function() {
		var a = [];
		for( var key in this.h.__keys__ ) {
		if(this.h.hasOwnProperty(key)) {
			a.push(this.h.__keys__[key]);
		}
		}
		return new haxe_iterators_ArrayIterator(a);
	}
	,__class__: haxe_ds_ObjectMap
};
var haxe_ds_StringMap = function() {
	this.h = Object.create(null);
};
haxe_ds_StringMap.__name__ = true;
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.createCopy = function(h) {
	var copy = new haxe_ds_StringMap();
	for (var key in h) copy.h[key] = h[key];
	return copy;
};
haxe_ds_StringMap.prototype = {
	__class__: haxe_ds_StringMap
};
var haxe_exceptions_PosException = function(message,previous,pos) {
	haxe_Exception.call(this,message,previous);
	if(pos == null) {
		this.posInfos = { fileName : "(unknown)", lineNumber : 0, className : "(unknown)", methodName : "(unknown)"};
	} else {
		this.posInfos = pos;
	}
};
haxe_exceptions_PosException.__name__ = true;
haxe_exceptions_PosException.__super__ = haxe_Exception;
haxe_exceptions_PosException.prototype = $extend(haxe_Exception.prototype,{
	toString: function() {
		return "" + haxe_Exception.prototype.toString.call(this) + " in " + this.posInfos.className + "." + this.posInfos.methodName + " at " + this.posInfos.fileName + ":" + this.posInfos.lineNumber;
	}
	,__class__: haxe_exceptions_PosException
});
var haxe_exceptions_NotImplementedException = function(message,previous,pos) {
	if(message == null) {
		message = "Not implemented";
	}
	haxe_exceptions_PosException.call(this,message,previous,pos);
};
haxe_exceptions_NotImplementedException.__name__ = true;
haxe_exceptions_NotImplementedException.__super__ = haxe_exceptions_PosException;
haxe_exceptions_NotImplementedException.prototype = $extend(haxe_exceptions_PosException.prototype,{
	__class__: haxe_exceptions_NotImplementedException
});
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
haxe_io_Bytes.__name__ = true;
haxe_io_Bytes.ofString = function(s,encoding) {
	if(encoding == haxe_io_Encoding.RawNative) {
		var buf = new Uint8Array(s.length << 1);
		var _g = 0;
		var _g1 = s.length;
		while(_g < _g1) {
			var i = _g++;
			var c = s.charCodeAt(i);
			buf[i << 1] = c & 255;
			buf[i << 1 | 1] = c >> 8;
		}
		return new haxe_io_Bytes(buf.buffer);
	}
	var a = [];
	var i = 0;
	while(i < s.length) {
		var c = s.charCodeAt(i++);
		if(55296 <= c && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
		}
		if(c <= 127) {
			a.push(c);
		} else if(c <= 2047) {
			a.push(192 | c >> 6);
			a.push(128 | c & 63);
		} else if(c <= 65535) {
			a.push(224 | c >> 12);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		} else {
			a.push(240 | c >> 18);
			a.push(128 | c >> 12 & 63);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		}
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.prototype = {
	__class__: haxe_io_Bytes
};
var haxe_io_BytesBuffer = function() {
	this.pos = 0;
	this.size = 0;
};
haxe_io_BytesBuffer.__name__ = true;
haxe_io_BytesBuffer.prototype = {
	addByte: function(byte) {
		if(this.pos == this.size) {
			this.grow(1);
		}
		this.view.setUint8(this.pos++,byte);
	}
	,grow: function(delta) {
		var req = this.pos + delta;
		var nsize = this.size == 0 ? 16 : this.size;
		while(nsize < req) nsize = nsize * 3 >> 1;
		var nbuf = new ArrayBuffer(nsize);
		var nu8 = new Uint8Array(nbuf);
		if(this.size > 0) {
			nu8.set(this.u8);
		}
		this.size = nsize;
		this.buffer = nbuf;
		this.u8 = nu8;
		this.view = new DataView(this.buffer);
	}
	,getBytes: function() {
		if(this.size == 0) {
			return new haxe_io_Bytes(new ArrayBuffer(0));
		}
		var b = new haxe_io_Bytes(this.buffer);
		b.length = this.pos;
		return b;
	}
	,__class__: haxe_io_BytesBuffer
};
var haxe_io_Output = function() { };
haxe_io_Output.__name__ = true;
haxe_io_Output.prototype = {
	writeByte: function(c) {
		throw new haxe_exceptions_NotImplementedException(null,null,{ fileName : "haxe/io/Output.hx", lineNumber : 47, className : "haxe.io.Output", methodName : "writeByte"});
	}
	,writeInt32: function(x) {
		if(this.bigEndian) {
			this.writeByte(x >>> 24);
			this.writeByte(x >> 16 & 255);
			this.writeByte(x >> 8 & 255);
			this.writeByte(x & 255);
		} else {
			this.writeByte(x & 255);
			this.writeByte(x >> 8 & 255);
			this.writeByte(x >> 16 & 255);
			this.writeByte(x >>> 24);
		}
	}
	,__class__: haxe_io_Output
};
var haxe_io_BytesOutput = function() {
	this.b = new haxe_io_BytesBuffer();
};
haxe_io_BytesOutput.__name__ = true;
haxe_io_BytesOutput.__super__ = haxe_io_Output;
haxe_io_BytesOutput.prototype = $extend(haxe_io_Output.prototype,{
	writeByte: function(c) {
		this.b.addByte(c);
	}
	,getBytes: function() {
		return this.b.getBytes();
	}
	,__class__: haxe_io_BytesOutput
});
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__:true,__constructs__:null
	,UTF8: {_hx_name:"UTF8",_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_name:"RawNative",_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
haxe_io_Encoding.__constructs__ = [haxe_io_Encoding.UTF8,haxe_io_Encoding.RawNative];
var haxe_io_FPHelper = function() { };
haxe_io_FPHelper.__name__ = true;
haxe_io_FPHelper.floatToI32 = function(f) {
	haxe_io_FPHelper.helper.setFloat32(0,f,true);
	return haxe_io_FPHelper.helper.getInt32(0,true);
};
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.__name__ = true;
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
	,__class__: haxe_iterators_ArrayIterator
};
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.getClass = function(o) {
	if(o == null) {
		return null;
	} else if(((o) instanceof Array)) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var con = e.__constructs__[o._hx_index];
			var n = con._hx_name;
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g = 0;
		var _g1 = intf.length;
		while(_g < _g1) {
			var i = _g++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		return ((o) instanceof Array);
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return o != null;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return ((o | 0) === o);
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(js_Boot.__downcastCheck(o,cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(((o) instanceof cl)) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return o.__enum__ != null ? $hxEnums[o.__enum__] == cl : false;
	}
};
js_Boot.__downcastCheck = function(o,cl) {
	if(!((o) instanceof cl)) {
		if(cl.__isInterface__) {
			return js_Boot.__interfLoop(js_Boot.getClass(o),cl);
		} else {
			return false;
		}
	} else {
		return true;
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var mnsl_MNSL = function() { };
mnsl_MNSL.__name__ = true;
mnsl_MNSL.fromSource = function(source,options) {
	return new mnsl_MNSLContext(source,options);
};
mnsl_MNSL.fromFile = function(file,options) {
	return new mnsl_MNSLContext("",options);
};
var mnsl_MNSLContext = function(source,options) {
	this._defines = options.defines;
	this._options = options;
	this._errors = [];
	this._warnings = [];
	if(this._options.rootPath == null) {
		this._options.rootPath = "./";
	}
	var preprocDefines = new haxe_ds_StringMap();
	var _g = 0;
	var _g1 = options.preprocessorDefines;
	while(_g < _g1.length) {
		var def = _g1[_g];
		++_g;
		preprocDefines.h[def] = 1;
	}
	var tokenizer = new mnsl_tokenizer_MNSLTokenizer(this,source,preprocDefines);
	var tokens = tokenizer.run();
	var parser = new mnsl_parser_MNSLParser(this,tokens);
	var res = parser.run();
	this._finalAst = res.ast;
	this._finalData = res.dataList;
	var analyser = new mnsl_analysis_MNSLAnalyser(this,res.ast);
	var output = analyser.run();
	this._finalAst = output;
	var optimizer = new mnsl_optimiser_MNSLOptimiser(this,output);
	var _g = 0;
	var _g1 = this._options.optimizerPlugins;
	while(_g < _g1.length) {
		var plugin = _g1[_g];
		++_g;
		optimizer.addPlugin(plugin);
	}
	var optimized = optimizer.run();
	this._finalAst = optimized;
};
mnsl_MNSLContext.__name__ = true;
mnsl_MNSLContext.prototype = {
	getOptions: function() {
		return this._options;
	}
	,log: function(message) {
		haxe_Log.trace(message,{ fileName : "mnsl/MNSLContext.hx", lineNumber : 78, className : "mnsl.MNSLContext", methodName : "log"});
	}
	,printAST: function(ast,indent) {
		if(indent == null) {
			indent = 0;
		}
		var indentStr = StringTools.lpad(""," ",indent * 2);
		var _g = 0;
		while(_g < ast.length) {
			var node = ast[_g];
			++_g;
			var name = $hxEnums[node.__enum__].__constructs__[node._hx_index]._hx_name;
			switch(node._hx_index) {
			case 0:
				var funcName = node.name;
				var returnType = node.returnType;
				var params = node.$arguments;
				var body = node.body;
				var info = node.info;
				this.log(indentStr + name + ("[" + funcName + ": " + Std.string(returnType) + "]"));
				this.printAST(body,indent + 1);
				break;
			case 1:
				var funcName1 = node.name;
				var args = node.args;
				var type = node.returnType;
				var info1 = node.info;
				this.log(indentStr + name + ("[" + funcName1 + ": " + Std.string(type) + "]"));
				this.printAST(args,indent + 1);
				break;
			case 2:
				var value = node.value;
				var type1 = node.type;
				var info2 = node.info;
				this.log(indentStr + name);
				this.printAST([value],indent + 1);
				break;
			case 3:
				var varName = node.name;
				var type2 = node.type;
				var value1 = node.value;
				var info3 = node.info;
				this.log(indentStr + name + ("[" + varName + ": " + Std.string(type2) + "]"));
				if(value1 != null) {
					this.printAST([value1],indent + 1);
				}
				break;
			case 4:
				var varName1 = node.name;
				var value2 = node.value;
				var info4 = node.info;
				this.log(indentStr + name + ("[" + Std.string(varName1) + "]"));
				this.printAST([value2],indent + 1);
				break;
			case 5:
				var identifierName = node.name;
				var type3 = node.type;
				var info5 = node.info;
				this.log(indentStr + name + ("[" + identifierName + ": " + Std.string(type3) + "]"));
				break;
			case 6:
				var condition = node.condition;
				var body1 = node.body;
				var info6 = node.info;
				this.log(indentStr + name);
				this.printAST([condition],indent + 1);
				this.printAST(body1,indent + 1);
				break;
			case 7:
				var condition1 = node.condition;
				var body2 = node.body;
				var info7 = node.info;
				this.log(indentStr + name);
				this.printAST([condition1],indent + 1);
				this.printAST(body2,indent + 1);
				break;
			case 8:
				var body3 = node.body;
				var info8 = node.info;
				this.log(indentStr + name);
				this.printAST(body3,indent + 1);
				break;
			case 9:
				var left = node.left;
				var op = node.op;
				var right = node.right;
				var type4 = node.type;
				var info9 = node.info;
				this.log(indentStr + name + ("[" + Std.string(op) + " -> " + Std.string(type4) + "]"));
				this.printAST([left,right],indent + 1);
				break;
			case 10:
				var op1 = node.op;
				var value3 = node.right;
				var info10 = node.info;
				this.log(indentStr + name + ("[" + Std.string(op1) + "]"));
				this.printAST([value3],indent + 1);
				break;
			case 11:
				var condition2 = node.condition;
				var body4 = node.body;
				var info11 = node.info;
				this.log(indentStr + name);
				this.printAST([condition2],indent + 1);
				this.printAST(body4,indent + 1);
				break;
			case 12:
				var init = node.init;
				var condition3 = node.condition;
				var increment = node.increment;
				var body5 = node.body;
				var info12 = node.info;
				this.log(indentStr + name);
				this.printAST([init,condition3,increment],indent + 1);
				this.printAST(body5,indent + 1);
				break;
			case 15:
				var value4 = node.node;
				var info13 = node.info;
				this.log(indentStr + name);
				this.printAST([value4],indent + 1);
				break;
			case 16:
				var body6 = node.body;
				var info14 = node.info;
				this.log(indentStr + name);
				this.printAST(body6,indent + 1);
				break;
			case 17:
				var structName = node.on;
				var field = node.field;
				var type5 = node.type;
				var info15 = node.info;
				this.log(indentStr + name + ("[" + Std.string(structName) + "." + field + " t=" + Std.string(type5) + "]"));
				break;
			case 18:
				var arrayName = node.on;
				var index = node.index;
				var info16 = node.info;
				this.log(indentStr + name + ("[" + Std.string(arrayName) + "[" + Std.string(index) + "]]"));
				break;
			case 19:
				var on = node.on;
				var from = node.from;
				var to = node.to;
				this.log(indentStr + name + ("[" + Std.string(from) + " -> " + Std.string(to) + "]"));
				this.printAST([on],indent + 1);
				break;
			case 22:
				var comp = node.components;
				var values = node.nodes;
				var info17 = node.info;
				this.log(indentStr + name + ("[Vec" + comp + "]"));
				this.printAST(values,indent + 1);
				break;
			case 23:
				var on1 = node.on;
				var fromComp = node.fromComponents;
				var toComp = node.toComponents;
				this.log(indentStr + name + ("[" + fromComp + " -> " + toComp + "]"));
				this.printAST([on1],indent + 1);
				break;
			case 24:
				var value5 = node.value;
				var info18 = node.info;
				this.log(indentStr + name + ("[" + value5 + "]"));
				break;
			case 25:
				var value6 = node.value;
				var info19 = node.info;
				this.log(indentStr + name + ("[" + value6 + "]"));
				break;
			case 26:
				var value7 = node.value;
				var info20 = node.info;
				this.log(indentStr + name + ("[" + value7 + "]"));
				break;
			default:
				this.log(indentStr + name);
			}
		}
	}
	,getDefines: function() {
		return this._defines;
	}
	,setDefineInt: function(key,value) {
		this._defines.h[key] = [mnsl_tokenizer_MNSLToken.IntegerLiteral("" + value,null)];
	}
	,setDefineFloat: function(key,value) {
		this._defines.h[key] = [mnsl_tokenizer_MNSLToken.FloatLiteral("" + value,null)];
	}
	,setDefine: function(key,value) {
		this._defines.h[key] = value;
	}
	,getDefine: function(key) {
		return this._defines.h[key];
	}
	,emitGLSL: function(config) {
		var p = new mnsl_glsl_MNSLGLSLPrinter(this,config);
		p.run();
		return p.getOutput();
	}
	,emitSPIRV: function(config) {
		var p = new mnsl_spirv_MNSLSPIRVPrinter(this,config);
		p.run();
		return p.getBytes();
	}
	,getAST: function() {
		return this._finalAst;
	}
	,getShaderData: function() {
		return this._finalData;
	}
	,emitError: function(error) {
		var _g = 0;
		var _g1 = this._errors;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			if(Std.string(e) == Std.string(error)) {
				return;
			}
		}
		this._errors.push(error);
	}
	,emitWarning: function(warning) {
		var _g = 0;
		var _g1 = this._warnings;
		while(_g < _g1.length) {
			var w = _g1[_g];
			++_g;
			if(Std.string(w) == Std.string(warning)) {
				return;
			}
		}
		this._warnings.push(warning);
	}
	,getErrors: function() {
		return this._errors;
	}
	,getWarnings: function() {
		return this._warnings;
	}
	,hasErrors: function() {
		return this._errors.length > 0;
	}
	,hasWarnings: function() {
		return this._warnings.length > 0;
	}
	,warningToString: function(warning) {
		switch(warning._hx_index) {
		case 0:
			var node = warning.node;
			var from = warning.from;
			var to = warning.to;
			return "ImplicitVectorTrunation: Vec" + from + " to Vec" + to + " at " + Std.string(node);
		case 1:
			var node = warning.node;
			return "Implicit conversion from float to int at " + Std.string(node);
		}
	}
	,errorToString: function(error) {
		switch(error._hx_index) {
		case 0:
			var char = error.char;
			var pos = error.pos;
			return "Invalid character: " + char + " at position " + Std.string(pos);
		case 1:
			var msg = error.msg;
			var pos = error.pos;
			return "Preprocessor error: " + msg + " at position " + Std.string(pos);
		case 2:
			var pos = error.pos;
			return "Unterminated string at position " + Std.string(pos);
		case 3:
			var token = error.token;
			return "Invalid token: " + Std.string(token);
		case 4:
			var value = error.value;
			var pos = error.pos;
			return "Invalid keyword: " + value + " at position " + Std.string(pos);
		case 5:
			var token = error.token;
			var pos = error.pos;
			return "Unexpected token: " + Std.string(token) + " at position " + Std.string(pos);
		case 6:
			var node = error.node;
			var pos = error.pos;
			return "Unexpected expression: " + Std.string(node) + " at position " + Std.string(pos);
		case 7:
			var pos = error.pos;
			return "Conditional statement without 'if' or 'elseif' at position " + Std.string(pos);
		case 8:
			var fn = error.fn;
			var pos = error.pos;
			return "No implementation for function: " + Std.string(fn) + " at " + Std.string(pos);
		case 9:
			var varName = error.name;
			var info = error.pos;
			return "Duplicate variable: " + varName + " at " + Std.string(info);
		case 10:
			var varName = error.name;
			var info = error.pos;
			return "Undefined variable: " + varName + " at " + Std.string(info);
		case 11:
			var pos = error.pos;
			return "Return statement outside of function at " + Std.string(pos);
		case 12:
			var func = error.func;
			var node = error.node;
			return "Missing return statement in function: " + Std.string(func) + " at " + Std.string(node);
		case 13:
			var constraint = error.constraint;
			return "Expected " + Std.string(constraint.mustBe) + " but got " + Std.string(constraint.type) + " at " + Std.string(constraint.ofNode);
		case 14:
			var type = error.type;
			var node = error.node;
			return "Unknown type: " + Std.string(type) + " at " + Std.string(node);
		case 15:
			var constraint = error.constraint;
			return "Unresolved constraint: " + Std.string(constraint);
		case 16:
			var on = error.on;
			return "Cannot assign to " + Std.string(on);
		case 17:
			var on = error.on;
			return "Cannot access on " + Std.string(on);
		case 18:
			var comp = error.comp;
			var info = error.info;
			return "Invalid amount of vector components: " + comp + " at " + Std.string(info);
		case 19:
			var func = error.functionName;
			var chain = error.recursionChain;
			var info = error.info;
			var chainStr = "";
			var _g = 0;
			var _g1 = chain.length;
			while(_g < _g1) {
				var i = _g++;
				if(i > 0) {
					chainStr += " -> ";
				}
				chainStr += chain[i];
			}
			return "Recursive function detected: " + func + " in chain: " + chainStr + " at " + Std.string(info);
		case 20:
			var node = error.node;
			var info = error.info;
			return "Type of vector component is unknown: " + Std.string(node) + " at vector " + Std.string(info);
		case 21:
			var tLeft = error.tLeft;
			var tRight = error.tRight;
			var op = error.op;
			var constraint = error.constraint;
			return "Invalid binary operation: " + Std.string(tLeft) + " " + op + " " + Std.string(tRight) + " at " + Std.string(constraint.ofNode);
		case 22:
			var op = error.op;
			var info = error.info;
			return "Invalid unary operation: " + Std.string(op) + " at " + Std.string(info);
		case 23:
			var node = error.node;
			var info = error.info;
			return $hxEnums[node.__enum__].__constructs__[node._hx_index]._hx_name + " outside of loop at " + Std.string(info);
		case 24:
			var limits = error.limits;
			var node = error.node;
			var limitStr = "";
			var _g = 0;
			var _g1 = limits.length;
			while(_g < _g1) {
				var limitIdx = _g++;
				if(limitIdx > 0) {
					limitStr += limitIdx == limits.length - 1 ? " or " : ", ";
				}
				limitStr += Std.string(limits[limitIdx]);
			}
			return Std.string(node) + " did not match any of the expected types: " + limitStr;
		}
	}
	,__class__: mnsl_MNSLContext
};
var mnsl_MNSLContextOptions = function(defines,rootPath,optimizerPlugins,preprocessorDefines,preprocessorIncludeFunc) {
	this.preprocessorIncludeFunc = function(path,root) {
		return null;
	};
	this.preprocessorDefines = [];
	this.optimizerPlugins = [new mnsl_optimiser_impl_MNSLOptimiseScalarVectorInit(),new mnsl_optimiser_impl_MNSLOptimiseSwizzleAssign(),new mnsl_optimiser_impl_MNSLOptimiseSwizzleAccess()];
	this.rootPath = null;
	this.defines = new haxe_ds_StringMap();
	if(defines != null) {
		this.defines = defines;
	}
	if(rootPath != null) {
		this.rootPath = rootPath;
	}
	if(optimizerPlugins != null) {
		this.optimizerPlugins = optimizerPlugins;
	}
	if(preprocessorDefines != null) {
		this.preprocessorDefines = preprocessorDefines;
	}
	if(preprocessorIncludeFunc != null) {
		this.preprocessorIncludeFunc = preprocessorIncludeFunc;
	}
};
mnsl_MNSLContextOptions.__name__ = true;
mnsl_MNSLContextOptions.prototype = {
	__class__: mnsl_MNSLContextOptions
};
var mnsl_MNSLError = $hxEnums["mnsl.MNSLError"] = { __ename__:true,__constructs__:null
	,TokenizerInvalidChar: ($_=function(char,pos) { return {_hx_index:0,char:char,pos:pos,__enum__:"mnsl.MNSLError",toString:$estr}; },$_._hx_name="TokenizerInvalidChar",$_.__params__ = ["char","pos"],$_)
	,TokenizerPreprocessorError: ($_=function(msg,pos) { return {_hx_index:1,msg:msg,pos:pos,__enum__:"mnsl.MNSLError",toString:$estr}; },$_._hx_name="TokenizerPreprocessorError",$_.__params__ = ["msg","pos"],$_)
	,TokenizerUnterminatedString: ($_=function(pos) { return {_hx_index:2,pos:pos,__enum__:"mnsl.MNSLError",toString:$estr}; },$_._hx_name="TokenizerUnterminatedString",$_.__params__ = ["pos"],$_)
	,ParserInvalidToken: ($_=function(token) { return {_hx_index:3,token:token,__enum__:"mnsl.MNSLError",toString:$estr}; },$_._hx_name="ParserInvalidToken",$_.__params__ = ["token"],$_)
	,ParserInvalidKeyword: ($_=function(value,pos) { return {_hx_index:4,value:value,pos:pos,__enum__:"mnsl.MNSLError",toString:$estr}; },$_._hx_name="ParserInvalidKeyword",$_.__params__ = ["value","pos"],$_)
	,ParserUnexpectedToken: ($_=function(token,pos) { return {_hx_index:5,token:token,pos:pos,__enum__:"mnsl.MNSLError",toString:$estr}; },$_._hx_name="ParserUnexpectedToken",$_.__params__ = ["token","pos"],$_)
	,ParserUnexpectedExpression: ($_=function(node,pos) { return {_hx_index:6,node:node,pos:pos,__enum__:"mnsl.MNSLError",toString:$estr}; },$_._hx_name="ParserUnexpectedExpression",$_.__params__ = ["node","pos"],$_)
	,ParserConditionalWithoutIf: ($_=function(pos) { return {_hx_index:7,pos:pos,__enum__:"mnsl.MNSLError",toString:$estr}; },$_._hx_name="ParserConditionalWithoutIf",$_.__params__ = ["pos"],$_)
	,AnalyserNoImplementation: ($_=function(fn,pos) { return {_hx_index:8,fn:fn,pos:pos,__enum__:"mnsl.MNSLError",toString:$estr}; },$_._hx_name="AnalyserNoImplementation",$_.__params__ = ["fn","pos"],$_)
	,AnalyserDuplicateVariable: ($_=function(name,pos) { return {_hx_index:9,name:name,pos:pos,__enum__:"mnsl.MNSLError",toString:$estr}; },$_._hx_name="AnalyserDuplicateVariable",$_.__params__ = ["name","pos"],$_)
	,AnalyserUndeclaredVariable: ($_=function(name,pos) { return {_hx_index:10,name:name,pos:pos,__enum__:"mnsl.MNSLError",toString:$estr}; },$_._hx_name="AnalyserUndeclaredVariable",$_.__params__ = ["name","pos"],$_)
	,AnalyserReturnOutsideFunction: ($_=function(pos) { return {_hx_index:11,pos:pos,__enum__:"mnsl.MNSLError",toString:$estr}; },$_._hx_name="AnalyserReturnOutsideFunction",$_.__params__ = ["pos"],$_)
	,AnalyserMissingReturn: ($_=function(func,node) { return {_hx_index:12,func:func,node:node,__enum__:"mnsl.MNSLError",toString:$estr}; },$_._hx_name="AnalyserMissingReturn",$_.__params__ = ["func","node"],$_)
	,AnalyserMismatchingType: ($_=function(constraint) { return {_hx_index:13,constraint:constraint,__enum__:"mnsl.MNSLError",toString:$estr}; },$_._hx_name="AnalyserMismatchingType",$_.__params__ = ["constraint"],$_)
	,AnalyserUnknownType: ($_=function(type,node) { return {_hx_index:14,type:type,node:node,__enum__:"mnsl.MNSLError",toString:$estr}; },$_._hx_name="AnalyserUnknownType",$_.__params__ = ["type","node"],$_)
	,AnalyserUnresolvedConstraint: ($_=function(constraint) { return {_hx_index:15,constraint:constraint,__enum__:"mnsl.MNSLError",toString:$estr}; },$_._hx_name="AnalyserUnresolvedConstraint",$_.__params__ = ["constraint"],$_)
	,AnalyserInvalidAssignment: ($_=function(on) { return {_hx_index:16,on:on,__enum__:"mnsl.MNSLError",toString:$estr}; },$_._hx_name="AnalyserInvalidAssignment",$_.__params__ = ["on"],$_)
	,AnalyserInvalidAccess: ($_=function(on) { return {_hx_index:17,on:on,__enum__:"mnsl.MNSLError",toString:$estr}; },$_._hx_name="AnalyserInvalidAccess",$_.__params__ = ["on"],$_)
	,AnalyserInvalidVectorComponent: ($_=function(comp,info) { return {_hx_index:18,comp:comp,info:info,__enum__:"mnsl.MNSLError",toString:$estr}; },$_._hx_name="AnalyserInvalidVectorComponent",$_.__params__ = ["comp","info"],$_)
	,AnalyserRecursiveFunction: ($_=function(functionName,recursionChain,info) { return {_hx_index:19,functionName:functionName,recursionChain:recursionChain,info:info,__enum__:"mnsl.MNSLError",toString:$estr}; },$_._hx_name="AnalyserRecursiveFunction",$_.__params__ = ["functionName","recursionChain","info"],$_)
	,AnalyserUnknownVectorComponent: ($_=function(node,info) { return {_hx_index:20,node:node,info:info,__enum__:"mnsl.MNSLError",toString:$estr}; },$_._hx_name="AnalyserUnknownVectorComponent",$_.__params__ = ["node","info"],$_)
	,AnalyserInvalidBinop: ($_=function(tLeft,tRight,op,constraint) { return {_hx_index:21,tLeft:tLeft,tRight:tRight,op:op,constraint:constraint,__enum__:"mnsl.MNSLError",toString:$estr}; },$_._hx_name="AnalyserInvalidBinop",$_.__params__ = ["tLeft","tRight","op","constraint"],$_)
	,AnalyserInvalidUnaryOp: ($_=function(op,info) { return {_hx_index:22,op:op,info:info,__enum__:"mnsl.MNSLError",toString:$estr}; },$_._hx_name="AnalyserInvalidUnaryOp",$_.__params__ = ["op","info"],$_)
	,AnalyserLoopKeywordOutsideLoop: ($_=function(node,info) { return {_hx_index:23,node:node,info:info,__enum__:"mnsl.MNSLError",toString:$estr}; },$_._hx_name="AnalyserLoopKeywordOutsideLoop",$_.__params__ = ["node","info"],$_)
	,AnalyserMismatchingEitherType: ($_=function(limits,node) { return {_hx_index:24,limits:limits,node:node,__enum__:"mnsl.MNSLError",toString:$estr}; },$_._hx_name="AnalyserMismatchingEitherType",$_.__params__ = ["limits","node"],$_)
};
mnsl_MNSLError.__constructs__ = [mnsl_MNSLError.TokenizerInvalidChar,mnsl_MNSLError.TokenizerPreprocessorError,mnsl_MNSLError.TokenizerUnterminatedString,mnsl_MNSLError.ParserInvalidToken,mnsl_MNSLError.ParserInvalidKeyword,mnsl_MNSLError.ParserUnexpectedToken,mnsl_MNSLError.ParserUnexpectedExpression,mnsl_MNSLError.ParserConditionalWithoutIf,mnsl_MNSLError.AnalyserNoImplementation,mnsl_MNSLError.AnalyserDuplicateVariable,mnsl_MNSLError.AnalyserUndeclaredVariable,mnsl_MNSLError.AnalyserReturnOutsideFunction,mnsl_MNSLError.AnalyserMissingReturn,mnsl_MNSLError.AnalyserMismatchingType,mnsl_MNSLError.AnalyserUnknownType,mnsl_MNSLError.AnalyserUnresolvedConstraint,mnsl_MNSLError.AnalyserInvalidAssignment,mnsl_MNSLError.AnalyserInvalidAccess,mnsl_MNSLError.AnalyserInvalidVectorComponent,mnsl_MNSLError.AnalyserRecursiveFunction,mnsl_MNSLError.AnalyserUnknownVectorComponent,mnsl_MNSLError.AnalyserInvalidBinop,mnsl_MNSLError.AnalyserInvalidUnaryOp,mnsl_MNSLError.AnalyserLoopKeywordOutsideLoop,mnsl_MNSLError.AnalyserMismatchingEitherType];
var mnsl_MNSLPrinter = function(context) {
	this._output = "";
	this._indent = 0;
	this._ast = context.getAST();
	this._context = context;
	this._inline = false;
	this._inlineCounter = 0;
};
mnsl_MNSLPrinter.__name__ = true;
mnsl_MNSLPrinter.prototype = {
	enableInline: function() {
		this._inlineCounter++;
		if(this._inlineCounter >= 1) {
			this._inline = true;
		}
	}
	,disableInline: function() {
		this._inlineCounter--;
		if(this._inlineCounter <= 0) {
			this._inline = false;
		}
	}
	,run: function() {
	}
	,template: function(content,args) {
		var result = content;
		var _g = 0;
		var _g1 = args.length;
		while(_g < _g1) {
			var i = _g++;
			var arg = args[i];
			result = StringTools.replace(result,"{" + i + "}",Std.string(arg));
		}
		return result;
	}
	,printlnIndented: function(content) {
		var $l=arguments.length;
		var args = new Array($l>1?$l-1:0);
		for(var $i=1;$i<$l;++$i){args[$i-1]=arguments[$i];}
		if(this._inline) {
			($_=this,$_.println.apply($_,[content].concat(args)));
			return;
		}
		this._output += StringTools.lpad(""," ",this._indent) + this.template(content,args.slice()) + "\n";
	}
	,println: function(content) {
		var $l=arguments.length;
		var args = new Array($l>1?$l-1:0);
		for(var $i=1;$i<$l;++$i){args[$i-1]=arguments[$i];}
		this._output += this.template(content,args.slice()) + (this._inline ? "" : "\n");
	}
	,print: function(content) {
		var $l=arguments.length;
		var args = new Array($l>1?$l-1:0);
		for(var $i=1;$i<$l;++$i){args[$i-1]=arguments[$i];}
		this._output += this.template(content,args.slice());
	}
	,printIndented: function(content) {
		var $l=arguments.length;
		var args = new Array($l>1?$l-1:0);
		for(var $i=1;$i<$l;++$i){args[$i-1]=arguments[$i];}
		if(this._inline) {
			($_=this,$_.print.apply($_,[content].concat(args)));
			return;
		}
		this._output += StringTools.lpad(""," ",this._indent) + this.template(content,args.slice());
	}
	,removeLastNewLine: function() {
		if(this._output.length > 0 && this._output.charAt(this._output.length - 1) == "\n") {
			this._output = HxOverrides.substr(this._output,0,this._output.length - 1);
		}
	}
	,removeLastSemicolon: function() {
		if(this._output.length > 0 && this._output.charAt(this._output.length - 1) == ";") {
			this._output = HxOverrides.substr(this._output,0,this._output.length - 1);
		}
	}
	,increaseIndent: function(by) {
		if(by == null) {
			by = 1;
		}
		this._indent += 4 * by;
	}
	,decreaseIndent: function(by) {
		if(by == null) {
			by = 1;
		}
		this._indent = Math.max(0,this._indent - 4 * by) | 0;
	}
	,setIndent: function(indent) {
		this._indent = indent * 4;
	}
	,getOutput: function() {
		return this._output;
	}
	,__class__: mnsl_MNSLPrinter
};
var mnsl_MNSLWarning = $hxEnums["mnsl.MNSLWarning"] = { __ename__:true,__constructs__:null
	,ImplicitVectorTruncation: ($_=function(node,from,to) { return {_hx_index:0,node:node,from:from,to:to,__enum__:"mnsl.MNSLWarning",toString:$estr}; },$_._hx_name="ImplicitVectorTruncation",$_.__params__ = ["node","from","to"],$_)
	,ImplicitFloatToInt: ($_=function(node) { return {_hx_index:1,node:node,__enum__:"mnsl.MNSLWarning",toString:$estr}; },$_._hx_name="ImplicitFloatToInt",$_.__params__ = ["node"],$_)
};
mnsl_MNSLWarning.__constructs__ = [mnsl_MNSLWarning.ImplicitVectorTruncation,mnsl_MNSLWarning.ImplicitFloatToInt];
var mnsl_analysis_MNSLAnalyser = function(context,ast) {
	var _g = new haxe_ds_StringMap();
	_g.h["x"] = { comp : 0, char : "x"};
	_g.h["y"] = { comp : 1, char : "y"};
	_g.h["z"] = { comp : 2, char : "z"};
	_g.h["w"] = { comp : 3, char : "w"};
	_g.h["r"] = { comp : 0, char : "x"};
	_g.h["g"] = { comp : 1, char : "y"};
	_g.h["b"] = { comp : 2, char : "z"};
	_g.h["a"] = { comp : 3, char : "w"};
	this._vectorAccess = _g;
	this._deferPostType = [];
	this._types = ["Void","Int","Float","Bool","Vec2","Vec3","Vec4","Mat2","Mat3","Mat4","Sampler","CTValue"];
	this._cpyStck = ["FunctionDecl","WhileLoop","ForLoop","IfStatement","ElseIfStatement","ElseStatement"];
	this._context = context;
	this._ast = ast;
	this._globalCtx = new mnsl_analysis_MNSLAnalyserContext();
	this._inputs = new mnsl_analysis_MNSLAnalyserVariable("input",new mnsl_analysis_MNSLType("CTValue"),true,[]);
	this._outputs = new mnsl_analysis_MNSLAnalyserVariable("output",new mnsl_analysis_MNSLType("CTValue"),true,[new mnsl_analysis_MNSLAnalyserVariable("Position",new mnsl_analysis_MNSLType("Vec4"),null,null)]);
	this._uniforms = new mnsl_analysis_MNSLAnalyserVariable("uniform",new mnsl_analysis_MNSLType("CTValue"),true,[]);
	this._functions = [new mnsl_analysis_MNSLAnalyserFunction("texture",[new mnsl_analysis_MNSLFuncArg("sampler",new mnsl_analysis_MNSLType("Sampler")),new mnsl_analysis_MNSLFuncArg("texCoord",new mnsl_analysis_MNSLType("Vec2"))],new mnsl_analysis_MNSLType("Vec4"),null,"__mnsl_texture"),new mnsl_analysis_MNSLAnalyserFunction("sin",[new mnsl_analysis_MNSLFuncArg("x",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4"),new mnsl_analysis_MNSLType("Mat2"),new mnsl_analysis_MNSLType("Mat3"),new mnsl_analysis_MNSLType("Mat4")]))],mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4"),new mnsl_analysis_MNSLType("Mat2"),new mnsl_analysis_MNSLType("Mat3"),new mnsl_analysis_MNSLType("Mat4")]),null,"__mnsl_sin"),new mnsl_analysis_MNSLAnalyserFunction("cos",[new mnsl_analysis_MNSLFuncArg("x",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4"),new mnsl_analysis_MNSLType("Mat2"),new mnsl_analysis_MNSLType("Mat3"),new mnsl_analysis_MNSLType("Mat4")]))],mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4"),new mnsl_analysis_MNSLType("Mat2"),new mnsl_analysis_MNSLType("Mat3"),new mnsl_analysis_MNSLType("Mat4")]),null,"__mnsl_cos"),new mnsl_analysis_MNSLAnalyserFunction("tan",[new mnsl_analysis_MNSLFuncArg("x",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4"),new mnsl_analysis_MNSLType("Mat2"),new mnsl_analysis_MNSLType("Mat3"),new mnsl_analysis_MNSLType("Mat4")]))],mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4"),new mnsl_analysis_MNSLType("Mat2"),new mnsl_analysis_MNSLType("Mat3"),new mnsl_analysis_MNSLType("Mat4")]),null,"__mnsl_tan"),new mnsl_analysis_MNSLAnalyserFunction("normalize",[new mnsl_analysis_MNSLFuncArg("v",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]))],mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]),null,"__mnsl_normalize"),new mnsl_analysis_MNSLAnalyserFunction("dot",[new mnsl_analysis_MNSLFuncArg("x",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")])),new mnsl_analysis_MNSLFuncArg("y",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]))],new mnsl_analysis_MNSLType("Float"),null,"__mnsl_dot"),new mnsl_analysis_MNSLAnalyserFunction("cross",[new mnsl_analysis_MNSLFuncArg("x",new mnsl_analysis_MNSLType("Vec3")),new mnsl_analysis_MNSLFuncArg("y",new mnsl_analysis_MNSLType("Vec3"))],new mnsl_analysis_MNSLType("Vec3"),null,"__mnsl_cross"),new mnsl_analysis_MNSLAnalyserFunction("length",[new mnsl_analysis_MNSLFuncArg("v",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]))],new mnsl_analysis_MNSLType("Float"),null,"__mnsl_length"),new mnsl_analysis_MNSLAnalyserFunction("reflect",[new mnsl_analysis_MNSLFuncArg("I",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")])),new mnsl_analysis_MNSLFuncArg("N",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]))],mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]),null,"__mnsl_reflect"),new mnsl_analysis_MNSLAnalyserFunction("refract",[new mnsl_analysis_MNSLFuncArg("I",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")])),new mnsl_analysis_MNSLFuncArg("N",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")])),new mnsl_analysis_MNSLFuncArg("eta",new mnsl_analysis_MNSLType("Float"))],mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]),null,"__mnsl_refract"),new mnsl_analysis_MNSLAnalyserFunction("pow",[new mnsl_analysis_MNSLFuncArg("x",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4"),new mnsl_analysis_MNSLType("Float")])),new mnsl_analysis_MNSLFuncArg("y",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4"),new mnsl_analysis_MNSLType("Float")]))],mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4"),new mnsl_analysis_MNSLType("Float")]),null,"__mnsl_pow"),new mnsl_analysis_MNSLAnalyserFunction("exp",[new mnsl_analysis_MNSLFuncArg("x",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]))],mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]),null,"__mnsl_exp"),new mnsl_analysis_MNSLAnalyserFunction("log",[new mnsl_analysis_MNSLFuncArg("x",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]))],mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]),null,"__mnsl_log"),new mnsl_analysis_MNSLAnalyserFunction("sqrt",[new mnsl_analysis_MNSLFuncArg("x",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]))],mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]),null,"__mnsl_sqrt"),new mnsl_analysis_MNSLAnalyserFunction("abs",[new mnsl_analysis_MNSLFuncArg("x",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]))],mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]),null,"__mnsl_abs"),new mnsl_analysis_MNSLAnalyserFunction("clamp",[new mnsl_analysis_MNSLFuncArg("x",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")])),new mnsl_analysis_MNSLFuncArg("minVal",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")])),new mnsl_analysis_MNSLFuncArg("maxVal",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]))],mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]),null,"__mnsl_clamp"),new mnsl_analysis_MNSLAnalyserFunction("mix",[new mnsl_analysis_MNSLFuncArg("x",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")])),new mnsl_analysis_MNSLFuncArg("y",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")])),new mnsl_analysis_MNSLFuncArg("a",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]))],mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]),null,"__mnsl_mix"),new mnsl_analysis_MNSLAnalyserFunction("step",[new mnsl_analysis_MNSLFuncArg("edge",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")])),new mnsl_analysis_MNSLFuncArg("x",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]))],mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]),null,"__mnsl_step"),new mnsl_analysis_MNSLAnalyserFunction("smoothstep",[new mnsl_analysis_MNSLFuncArg("edge0",mnsl_analysis_MNSLType.Template("E",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")])),new mnsl_analysis_MNSLFuncArg("edge1",mnsl_analysis_MNSLType.Template("E",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")])),new mnsl_analysis_MNSLFuncArg("x",mnsl_analysis_MNSLType.Template("X",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]))],mnsl_analysis_MNSLType.Template("X",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]),null,"__mnsl_smoothstep"),new mnsl_analysis_MNSLAnalyserFunction("max",[new mnsl_analysis_MNSLFuncArg("x",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")])),new mnsl_analysis_MNSLFuncArg("y",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]))],mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]),null,"__mnsl_max"),new mnsl_analysis_MNSLAnalyserFunction("min",[new mnsl_analysis_MNSLFuncArg("x",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")])),new mnsl_analysis_MNSLFuncArg("y",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]))],mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]),null,"__mnsl_min"),new mnsl_analysis_MNSLAnalyserFunction("atan",[new mnsl_analysis_MNSLFuncArg("y",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")])),new mnsl_analysis_MNSLFuncArg("x",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]))],mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]),null,"__mnsl_atan"),new mnsl_analysis_MNSLAnalyserFunction("acos",[new mnsl_analysis_MNSLFuncArg("x",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]))],mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]),null,"__mnsl_acos"),new mnsl_analysis_MNSLAnalyserFunction("asin",[new mnsl_analysis_MNSLFuncArg("x",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]))],mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]),null,"__mnsl_asin"),new mnsl_analysis_MNSLAnalyserFunction("mod",[new mnsl_analysis_MNSLFuncArg("x",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")])),new mnsl_analysis_MNSLFuncArg("y",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]))],mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]),null,"__mnsl_mod"),new mnsl_analysis_MNSLAnalyserFunction("fract",[new mnsl_analysis_MNSLFuncArg("x",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]))],mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]),null,"__mnsl_fract"),new mnsl_analysis_MNSLAnalyserFunction("floor",[new mnsl_analysis_MNSLFuncArg("x",mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]))],mnsl_analysis_MNSLType.Template("T",[new mnsl_analysis_MNSLType("Float"),new mnsl_analysis_MNSLType("Vec2"),new mnsl_analysis_MNSLType("Vec3"),new mnsl_analysis_MNSLType("Vec4")]),null,"__mnsl_floor")];
	var _g = new haxe_ds_EnumValueMap();
	_g.set(mnsl_parser_MNSLShaderDataKind.Input,this._inputs);
	_g.set(mnsl_parser_MNSLShaderDataKind.Output,this._outputs);
	_g.set(mnsl_parser_MNSLShaderDataKind.Uniform,this._uniforms);
	var varMap = _g;
	var _g = 0;
	var _g1 = this._context.getShaderData();
	while(_g < _g1.length) {
		var d = _g1[_g];
		++_g;
		var toCat = varMap.get(d.kind);
		toCat.fields.push(new mnsl_analysis_MNSLAnalyserVariable(d.name,d.type,null,null));
	}
	this._globalCtx.variables.push(this._inputs);
	this._globalCtx.variables.push(this._outputs);
	this._globalCtx.variables.push(this._uniforms);
	this._globalCtx.functions = this._globalCtx.functions.concat(this._functions);
	this._solver = new mnsl_analysis_MNSLSolver(context);
};
mnsl_analysis_MNSLAnalyser.__name__ = true;
mnsl_analysis_MNSLAnalyser.getType = function(node) {
	if(node == null) {
		return new mnsl_analysis_MNSLType("Unknown");
	}
	switch(node._hx_index) {
	case 0:
		var _g = node.body;
		var _g = node.info;
		var name = node.name;
		var returnType = node.returnType;
		var args = node.$arguments;
		return returnType;
	case 1:
		var _g = node.info;
		var name = node.name;
		var args = node.args;
		var returnType = node.returnType;
		return returnType;
	case 2:
		var _g = node.type;
		var _g = node.info;
		var value = node.value;
		return mnsl_analysis_MNSLAnalyser.getType(value);
	case 3:
		var _g = node.info;
		var name = node.name;
		var type = node.type;
		var value = node.value;
		return type;
	case 5:
		var _g = node.info;
		var name = node.name;
		var type = node.type;
		return type;
	case 9:
		var _g = node.info;
		var left = node.left;
		var op = node.op;
		var right = node.right;
		var type = node.type;
		return type;
	case 10:
		var _g = node.info;
		var op = node.op;
		var value = node.right;
		return mnsl_analysis_MNSLAnalyser.getType(value);
	case 15:
		var _g = node.info;
		var value = node.node;
		return mnsl_analysis_MNSLAnalyser.getType(value);
	case 17:
		var _g = node.info;
		var on = node.on;
		var field = node.field;
		var type = node.type;
		return type;
	case 18:
		var on = node.on;
		var index = node.index;
		var info = node.info;
		var _this = mnsl_analysis_MNSLAnalyser.getType(on);
		var tmp = _this._arrayBaseType;
		if(tmp != null) {
			return tmp;
		} else {
			return _this;
		}
		break;
	case 19:
		var on = node.on;
		var from = node.from;
		var to = node.to;
		return to;
	case 20:
		var _g = node.info;
		return new mnsl_analysis_MNSLType("Void");
	case 22:
		var _g = node.info;
		var comp = node.components;
		var values = node.nodes;
		return new mnsl_analysis_MNSLType("Vec" + comp);
	case 23:
		var on = node.on;
		var fromComp = node.fromComponents;
		var toComp = node.toComponents;
		return new mnsl_analysis_MNSLType("Vec" + toComp);
	case 24:
		var _g = node.info;
		var value = node.value;
		return new mnsl_analysis_MNSLType("Int");
	case 25:
		var _g = node.info;
		var value = node.value;
		return new mnsl_analysis_MNSLType("Float");
	case 26:
		var _g = node.info;
		var value = node.value;
		return new mnsl_analysis_MNSLType("String");
	case 27:
		var _g = node.info;
		var value = node.value;
		return new mnsl_analysis_MNSLType("Bool");
	default:
		return new mnsl_analysis_MNSLType("Unknown");
	}
};
mnsl_analysis_MNSLAnalyser.prototype = {
	execAtNode: function(node,ctx) {
		if(node == null) {
			return null;
		}
		var eNode = Type.getEnum(node);
		var name = $hxEnums[node.__enum__].__constructs__[node._hx_index]._hx_name;
		var params = Type.enumParameters(node);
		var resPre = this.execAtNodePre(node,ctx);
		if(resPre != null) {
			name = $hxEnums[resPre.__enum__].__constructs__[resPre._hx_index]._hx_name;
			params = Type.enumParameters(resPre);
			node = resPre;
		}
		if(this._cpyStck.indexOf(name) != -1) {
			ctx = ctx.copy();
			if(name == "FunctionDecl") {
				var args = params[2];
				var _g = 0;
				while(_g < args.length) {
					var arg = args[_g];
					++_g;
					ctx.variables.push(new mnsl_analysis_MNSLAnalyserVariable(arg.name,arg.type,null,null));
				}
			}
			if(name == "WhileLoop" || name == "ForLoop") {
				ctx.currentIsLoop = true;
			}
		}
		var _g = 0;
		var _g1 = params.length;
		while(_g < _g1) {
			var pi = _g++;
			var p = params[pi];
			if(js_Boot.__instanceof(p,mnsl_parser_MNSLNode)) {
				params[pi] = this.execAtNode(p,ctx);
				continue;
			}
			if(((p) instanceof Array) && p[0] != null && js_Boot.__instanceof(p[0],mnsl_parser_MNSLNode)) {
				params[pi] = this.execAtBody(p,ctx);
				continue;
			}
		}
		this._solver.solve();
		node = Type.createEnum(eNode,name,params);
		var resPost = this.execAtNodePost(node,ctx);
		if(resPost != null) {
			name = $hxEnums[resPost.__enum__].__constructs__[resPost._hx_index]._hx_name;
			params = Type.enumParameters(resPost);
			node = resPost;
		}
		return node;
	}
	,execAtNodePre: function(node,ctx) {
		if(node._hx_index == 0) {
			var _g = node.body;
			var name = node.name;
			var returnType = node.returnType;
			var args = node.$arguments;
			var info = node.info;
			return this.analyseFunctionDeclPre(node,name,returnType,args,ctx,info);
		} else {
			return node;
		}
	}
	,analyseFunctionDeclPre: function(node,name,returnType,args,ctx,info) {
		if(!(returnType._type != "Unknown" && !returnType._tempType)) {
			returnType.setType(new mnsl_analysis_MNSLType("Void"));
			returnType.setTempType(true);
		}
		var _g = 0;
		while(_g < args.length) {
			var arg = args[_g];
			++_g;
			var _this = arg.type;
			if(!(_this._type != "Unknown" && !_this._tempType)) {
				arg.type.setType(new mnsl_analysis_MNSLType("Void"));
				arg.type.setTempType(true);
			}
		}
		var f = new mnsl_analysis_MNSLAnalyserFunction(name,args,returnType,true,null);
		ctx.functions.push(f);
		ctx.currentFunction = f;
		return node;
	}
	,analyseVariableDeclPost: function(node,name,type,value,ctx,info) {
		if(ctx.findVariable(name) != null) {
			this._context.emitError(mnsl_MNSLError.AnalyserDuplicateVariable(name,info));
			return node;
		}
		this._solver.addConstraint(new mnsl_analysis_MNSLConstraint(mnsl_analysis_MNSLAnalyser.getType(value),value,type,null,null,null,null));
		ctx.variables.push(new mnsl_analysis_MNSLAnalyserVariable(name,type,null,null));
		return node;
	}
	,getVariableOf: function(node,info,ctx) {
		var _gthis = this;
		var structStck = [];
		var findName = null;
		findName = function(node) {
			switch(node._hx_index) {
			case 5:
				var _g = node.type;
				var _g = node.info;
				var name = node.name;
				return name;
			case 17:
				var on = node.on;
				var field = node.field;
				var type = node.type;
				var info = node.info;
				structStck.push(field);
				return findName(on);
			default:
				_gthis._context.emitError(mnsl_MNSLError.AnalyserInvalidAccess(node));
				return null;
			}
		};
		var currCtx = ctx;
		var currField = findName(node);
		var currName = currField;
		var accessOk = true;
		var v = null;
		while(accessOk) {
			v = currCtx.findVariable(currField);
			if(v == null) {
				accessOk = false;
				break;
			}
			currCtx = new mnsl_analysis_MNSLAnalyserContext();
			currCtx.variables = currCtx.variables.concat(v.fields);
			if(structStck.length <= 0) {
				break;
			}
			currField = structStck.pop();
			currName += "." + currField;
			currCtx = new mnsl_analysis_MNSLAnalyserContext();
			currCtx.variables = currCtx.variables.concat(v.fields);
		}
		if(!accessOk) {
			this._context.emitError(mnsl_MNSLError.AnalyserUndeclaredVariable(currName,info));
			return null;
		}
		return v;
	}
	,analyseVariableAssignPost: function(node,on,value,ctx,info) {
		switch(on._hx_index) {
		case 17:
			var accessOn = on.on;
			var field = on.field;
			var type = on.type;
			var structInfo = on.info;
			var t = mnsl_analysis_MNSLAnalyser.getType(accessOn);
			if(t._type == "Vec" + 2 || t._type == "Vec" + 3 || t._type == "Vec" + 4) {
				if(Object.prototype.hasOwnProperty.call(this._vectorAccess.h,field)) {
					var vecAccess = this._vectorAccess.h[field];
					var tmp;
					switch(t._type) {
					case "Vec2":
						tmp = 2;
						break;
					case "Vec3":
						tmp = 3;
						break;
					case "Vec4":
						tmp = 4;
						break;
					default:
						tmp = -1;
					}
					if(vecAccess.comp >= tmp) {
						this._context.emitError(mnsl_MNSLError.AnalyserInvalidVectorComponent(vecAccess.comp,info));
						return node;
					}
					this._solver.addConstraint(new mnsl_analysis_MNSLConstraint(mnsl_analysis_MNSLAnalyser.getType(value),value,new mnsl_analysis_MNSLType("Float"),null,null,null,null));
					return mnsl_parser_MNSLNode.VariableAssign(mnsl_parser_MNSLNode.StructAccess(accessOn,this._vectorAccess.h[field].char,type,structInfo),value,info);
				} else {
					this._context.emitError(mnsl_MNSLError.AnalyserUndeclaredVariable("VectorAccess(" + Std.string(t) + "." + field + ")",info));
					return node;
				}
			}
			break;
		case 22:
			var _g = on.info;
			var comp = on.components;
			var values = on.nodes;
			this._solver.addConstraint(new mnsl_analysis_MNSLConstraint(mnsl_analysis_MNSLAnalyser.getType(value),value,new mnsl_analysis_MNSLType("Vec" + comp),null,null,null,null));
			var blockBody = [];
			var componentOrder = ["x","y","z","w"];
			var _g = 0;
			var _g1 = values.length;
			while(_g < _g1) {
				var cIdx = _g++;
				blockBody.push(mnsl_parser_MNSLNode.VariableAssign(values[cIdx],mnsl_parser_MNSLNode.StructAccess(mnsl_parser_MNSLNode.SubExpression(value,info),componentOrder[cIdx],new mnsl_analysis_MNSLType("Vec" + comp),info),info));
			}
			return mnsl_parser_MNSLNode.Block(blockBody,info);
		default:
		}
		var v = this.getVariableOf(on,info,ctx);
		if(v == null) {
			return node;
		}
		this._solver.addConstraint(new mnsl_analysis_MNSLConstraint(mnsl_analysis_MNSLAnalyser.getType(value),value,v.type,null,null,null,null));
		return node;
	}
	,analyseIdentifierPost: function(node,name,type,ctx,info) {
		var v = ctx.findVariable(name);
		if(v == null) {
			this._context.emitError(mnsl_MNSLError.AnalyserUndeclaredVariable(name,info));
			return node;
		}
		return mnsl_parser_MNSLNode.Identifier(name,v.type,info);
	}
	,analyseStructAccessPost: function(node,on,field,type,ctx,info) {
		var t = mnsl_analysis_MNSLAnalyser.getType(on);
		if(t._type != "Unknown" && !t._tempType && (t._type == "Vec" + 2 || t._type == "Vec" + 3 || t._type == "Vec" + 4)) {
			var parts = field.split("");
			if(parts.length == 1) {
				if(!Object.prototype.hasOwnProperty.call(this._vectorAccess.h,parts[0])) {
					this._context.emitError(mnsl_MNSLError.AnalyserUndeclaredVariable("VectorAccess(" + Std.string(t) + "." + field + ")",info));
					return node;
				}
				var tmp = this._vectorAccess.h[parts[0]];
				var tmp1;
				switch(t._type) {
				case "Vec2":
					tmp1 = 2;
					break;
				case "Vec3":
					tmp1 = 3;
					break;
				case "Vec4":
					tmp1 = 4;
					break;
				default:
					tmp1 = -1;
				}
				if(tmp.comp >= tmp1) {
					this._context.emitError(mnsl_MNSLError.AnalyserInvalidVectorComponent(this._vectorAccess.h[parts[0]].comp,info));
					return node;
				}
				this._solver.addConstraint(new mnsl_analysis_MNSLConstraint(type,node,new mnsl_analysis_MNSLType("Float"),null,null,null,null));
				return mnsl_parser_MNSLNode.StructAccess(on,this._vectorAccess.h[parts[0]].char,type,info);
			}
			var newComps = [];
			var _g = 0;
			while(_g < parts.length) {
				var c = parts[_g];
				++_g;
				if(!Object.prototype.hasOwnProperty.call(this._vectorAccess.h,c)) {
					this._context.emitError(mnsl_MNSLError.AnalyserUndeclaredVariable("VectorAccess(" + Std.string(t) + "." + field + ")",info));
					return node;
				}
				var tmp = this._vectorAccess.h[c];
				var tmp1;
				switch(t._type) {
				case "Vec2":
					tmp1 = 2;
					break;
				case "Vec3":
					tmp1 = 3;
					break;
				case "Vec4":
					tmp1 = 4;
					break;
				default:
					tmp1 = -1;
				}
				if(tmp.comp >= tmp1) {
					this._context.emitError(mnsl_MNSLError.AnalyserInvalidVectorComponent(this._vectorAccess.h[c].comp,info));
					return node;
				}
				newComps.push(mnsl_parser_MNSLNode.StructAccess(on,this._vectorAccess.h[c].char,type,info));
			}
			this._solver.addConstraint(new mnsl_analysis_MNSLConstraint(type,node,new mnsl_analysis_MNSLType("Vec" + newComps.length),null,null,null,null));
			return mnsl_parser_MNSLNode.VectorCreation(newComps.length,newComps,info);
		}
		var v = this.getVariableOf(node,info,ctx);
		if(v == null) {
			return node;
		}
		this._solver.addConstraint(new mnsl_analysis_MNSLConstraint(type,node,v.type,null,null,null,null));
		return node;
	}
	,analyseFunctionCallPost: function(node,name,args,returnType,ctx,info) {
		var result = new Array(args.length);
		var _g = 0;
		var _g1 = args.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = mnsl_analysis_MNSLAnalyser.getType(args[i]);
		}
		var f = ctx.findFunction(name,result,true);
		if(f == null) {
			var tmp = this._context;
			var _g = name;
			var result = new Array(args.length);
			var _g1 = 0;
			var _g2 = args.length;
			while(_g1 < _g2) {
				var i = _g1++;
				result[i] = new mnsl_analysis_MNSLFuncArg("",mnsl_analysis_MNSLAnalyser.getType(args[i]));
			}
			tmp.emitError(mnsl_MNSLError.AnalyserNoImplementation(new mnsl_analysis_MNSLAnalyserFunction(_g,result,returnType,null,null),info));
			return node;
		}
		var templates_h = Object.create(null);
		var _g = 0;
		var _g1 = args.length;
		while(_g < _g1) {
			var i = _g++;
			var arg = args[i];
			var argType = mnsl_analysis_MNSLAnalyser.getType(arg);
			var _this = f.args[i].type;
			if(StringTools.startsWith(_this._type,"Template<") && StringTools.endsWith(_this._type,">")) {
				var _this1 = f.args[i].type;
				var key = StringTools.startsWith(_this1._type,"Template<") && StringTools.endsWith(_this1._type,">");
				if(!Object.prototype.hasOwnProperty.call(templates_h,!key ? null : HxOverrides.substr(_this1._type,9,_this1._type.length - 10))) {
					var t = new mnsl_analysis_MNSLType("Unknown");
					t.setLimits(f.args[i].type._limits);
					var _this2 = f.args[i].type;
					templates_h[!(StringTools.startsWith(_this2._type,"Template<") && StringTools.endsWith(_this2._type,">")) ? null : HxOverrides.substr(_this2._type,9,_this2._type.length - 10)] = t;
				}
				var _this3 = f.args[i].type;
				this._solver.addConstraint(new mnsl_analysis_MNSLConstraint(argType,arg,templates_h[!(StringTools.startsWith(_this3._type,"Template<") && StringTools.endsWith(_this3._type,">")) ? null : HxOverrides.substr(_this3._type,9,_this3._type.length - 10)],null,null,null,null));
				continue;
			}
			this._solver.addConstraint(new mnsl_analysis_MNSLConstraint(argType,arg,f.args[i].type,null,null,null,null));
		}
		var _this = f.returnType;
		if(StringTools.startsWith(_this._type,"Template<") && StringTools.endsWith(_this._type,">")) {
			var _this = f.returnType;
			var key = StringTools.startsWith(_this._type,"Template<") && StringTools.endsWith(_this._type,">");
			if(!Object.prototype.hasOwnProperty.call(templates_h,!key ? null : HxOverrides.substr(_this._type,9,_this._type.length - 10))) {
				var _this = f.returnType;
				templates_h[!(StringTools.startsWith(_this._type,"Template<") && StringTools.endsWith(_this._type,">")) ? null : HxOverrides.substr(_this._type,9,_this._type.length - 10)] = new mnsl_analysis_MNSLType("Unknown");
			}
			var _this = f.returnType;
			this._solver.addConstraint(new mnsl_analysis_MNSLConstraint(returnType,node,templates_h[!(StringTools.startsWith(_this._type,"Template<") && StringTools.endsWith(_this._type,">")) ? null : HxOverrides.substr(_this._type,9,_this._type.length - 10)],null,null,null,null));
		} else {
			this._solver.addConstraint(new mnsl_analysis_MNSLConstraint(returnType,node,f.returnType,null,null,null,null));
		}
		return node;
	}
	,analyseReturnPost: function(node,value,type,ctx,info) {
		if(ctx.currentFunction == null) {
			this._context.emitError(mnsl_MNSLError.AnalyserReturnOutsideFunction(info));
			return node;
		}
		this._solver.addConstraint(new mnsl_analysis_MNSLConstraint(mnsl_analysis_MNSLAnalyser.getType(value),value,ctx.currentFunction.returnType,null,null,null,null));
		return node;
	}
	,analyseVectorCreationPost: function(node,comp,nodes,ctx,info) {
		if(comp > 4 || comp < 2) {
			this._context.emitError(mnsl_MNSLError.AnalyserInvalidVectorComponent(comp,info));
			return node;
		}
		var newComp = 0;
		var newNodes = [];
		var _g = 0;
		while(_g < nodes.length) {
			var arg = nodes[_g];
			++_g;
			var t = mnsl_analysis_MNSLAnalyser.getType(arg);
			if(!(t._type != "Unknown" && !t._tempType)) {
				this._context.emitError(mnsl_MNSLError.AnalyserUnknownVectorComponent(arg,info));
				return node;
			}
			if(t._type == "Vec" + 2 || t._type == "Vec" + 3 || t._type == "Vec" + 4) {
				var compArr = ["x","y","z","w"];
				var _g1 = 0;
				var _g2;
				switch(t._type) {
				case "Vec2":
					_g2 = 2;
					break;
				case "Vec3":
					_g2 = 3;
					break;
				case "Vec4":
					_g2 = 4;
					break;
				default:
					_g2 = -1;
				}
				while(_g1 < _g2) {
					var cIdx = _g1++;
					var tmp;
					switch(t._type) {
					case "Vec2":
						tmp = 2;
						break;
					case "Vec3":
						tmp = 3;
						break;
					case "Vec4":
						tmp = 4;
						break;
					default:
						tmp = -1;
					}
					if(cIdx < tmp) {
						newNodes.push(mnsl_parser_MNSLNode.StructAccess(arg,compArr[cIdx],new mnsl_analysis_MNSLType("Float"),info));
						++newComp;
					}
				}
			} else {
				newNodes.push(arg);
				++newComp;
			}
		}
		if(newComp != comp) {
			if(newComp < comp) {
				if(newComp == 1) {
					while(newComp < comp) {
						newNodes.push(newNodes[0]);
						++newComp;
					}
				} else {
					while(newComp < comp) {
						if(newComp == 3) {
							newNodes.push(mnsl_parser_MNSLNode.FloatLiteralNode("1.0",info));
						} else {
							newNodes.push(mnsl_parser_MNSLNode.FloatLiteralNode("0.0",info));
						}
						++newComp;
					}
				}
			} else if(newComp > 4) {
				newNodes = newNodes.slice(0,4);
				newComp = comp;
			}
		}
		if(newComp > 4 || newComp < 2) {
			this._context.emitError(mnsl_MNSLError.AnalyserInvalidVectorComponent(newComp,info));
			return node;
		}
		return mnsl_parser_MNSLNode.VectorCreation(newComp,newNodes,info);
	}
	,analyseBinaryOpPost: function(node,left,op,right,type,ctx,info) {
		var leftType = mnsl_analysis_MNSLAnalyser.getType(left);
		var rightType = mnsl_analysis_MNSLAnalyser.getType(right);
		var opName;
		switch(op._hx_index) {
		case 14:
			var _g = op.info;
			opName = "-";
			break;
		case 15:
			var _g = op.info;
			opName = "+";
			break;
		case 17:
			var _g = op.info;
			opName = "/";
			break;
		case 18:
			var _g = op.info;
			opName = "*";
			break;
		case 19:
			var _g = op.info;
			opName = "%";
			break;
		case 20:
			var _g = op.info;
			opName = "?";
			break;
		case 22:
			var _g = op.info;
			opName = "=";
			break;
		case 23:
			var _g = op.info;
			opName = ":";
			break;
		case 24:
			var _g = op.info;
			opName = "...";
			break;
		case 25:
			var _g = op.info;
			opName = "&&";
			break;
		case 26:
			var _g = op.info;
			opName = "||";
			break;
		case 27:
			var _g = op.info;
			opName = "<";
			break;
		case 28:
			var _g = op.info;
			opName = ">";
			break;
		case 29:
			var _g = op.info;
			opName = "<=";
			break;
		case 30:
			var _g = op.info;
			opName = ">=";
			break;
		case 31:
			var _g = op.info;
			opName = "!=";
			break;
		case 32:
			var _g = op.info;
			opName = "!";
			break;
		default:
			opName = "<->";
		}
		this._solver.addConstraint(new mnsl_analysis_MNSLConstraint(rightType,right,leftType,true,true,opName,null));
		this._solver.addConstraint(new mnsl_analysis_MNSLConstraint(leftType,left,rightType,true,true,opName,null));
		var resType;
		switch(op._hx_index) {
		case 17:
			var _g = op.info;
			resType = rightType._type == "Int" ? new mnsl_analysis_MNSLType("Float") : rightType;
			break;
		case 22:
			var _g = op.info;
			resType = new mnsl_analysis_MNSLType("Bool");
			break;
		case 25:
			var _g = op.info;
			resType = new mnsl_analysis_MNSLType("Bool");
			break;
		case 26:
			var _g = op.info;
			resType = new mnsl_analysis_MNSLType("Bool");
			break;
		case 27:
			var _g = op.info;
			resType = new mnsl_analysis_MNSLType("Bool");
			break;
		case 28:
			var _g = op.info;
			resType = new mnsl_analysis_MNSLType("Bool");
			break;
		case 29:
			var _g = op.info;
			resType = new mnsl_analysis_MNSLType("Bool");
			break;
		case 30:
			var _g = op.info;
			resType = new mnsl_analysis_MNSLType("Bool");
			break;
		case 31:
			var _g = op.info;
			resType = new mnsl_analysis_MNSLType("Bool");
			break;
		default:
			resType = rightType;
		}
		this._solver.addConstraint(new mnsl_analysis_MNSLConstraint(type,node,resType,null,null,null,right));
		return node;
	}
	,analyseConditionalPost: function(node,cond,body,ctx,info) {
		this._solver.addConstraint(new mnsl_analysis_MNSLConstraint(mnsl_analysis_MNSLAnalyser.getType(cond),cond,new mnsl_analysis_MNSLType("Bool"),null,null,null,null));
		return node;
	}
	,analyseUnaryOpPost: function(node,op,value,ctx,info) {
		var isAllowed;
		switch(op._hx_index) {
		case 14:
			var _g = op.info;
			isAllowed = true;
			break;
		case 15:
			var _g = op.info;
			isAllowed = true;
			break;
		case 32:
			var _g = op.info;
			isAllowed = true;
			break;
		default:
			isAllowed = false;
		}
		if(!isAllowed) {
			this._context.emitError(mnsl_MNSLError.AnalyserInvalidUnaryOp(op,info));
			return node;
		}
		return node;
	}
	,analyseLoopKeyword: function(node,ctx,info) {
		if(!ctx.currentIsLoop) {
			this._context.emitError(mnsl_MNSLError.AnalyserLoopKeywordOutsideLoop(node,info));
			return node;
		}
		return node;
	}
	,execAtNodePost: function(node,ctx) {
		switch(node._hx_index) {
		case 1:
			var name = node.name;
			var args = node.args;
			var returnType = node.returnType;
			var info = node.info;
			return this.analyseFunctionCallPost(node,name,args,returnType,ctx,info);
		case 2:
			var value = node.value;
			var type = node.type;
			var info = node.info;
			return this.analyseReturnPost(node,value,type,ctx,info);
		case 3:
			var name = node.name;
			var type = node.type;
			var value = node.value;
			var info = node.info;
			return this.analyseVariableDeclPost(node,name,type,value,ctx,info);
		case 4:
			var on = node.name;
			var value = node.value;
			var info = node.info;
			return this.analyseVariableAssignPost(node,on,value,ctx,info);
		case 5:
			var name = node.name;
			var type = node.type;
			var info = node.info;
			return this.analyseIdentifierPost(node,name,type,ctx,info);
		case 6:
			var cond = node.condition;
			var body = node.body;
			var info = node.info;
			return this.analyseConditionalPost(node,cond,body,ctx,info);
		case 7:
			var cond = node.condition;
			var body = node.body;
			var info = node.info;
			return this.analyseConditionalPost(node,cond,body,ctx,info);
		case 9:
			var left = node.left;
			var op = node.op;
			var right = node.right;
			var type = node.type;
			var info = node.info;
			return this.analyseBinaryOpPost(node,left,op,right,type,ctx,info);
		case 10:
			var op = node.op;
			var value = node.right;
			var info = node.info;
			return this.analyseUnaryOpPost(node,op,value,ctx,info);
		case 11:
			var cond = node.condition;
			var body = node.body;
			var info = node.info;
			return this.analyseConditionalPost(node,cond,body,ctx,info);
		case 12:
			var init = node.init;
			var condition = node.condition;
			var increment = node.increment;
			var body = node.body;
			var info = node.info;
			return this.analyseConditionalPost(node,condition,body,ctx,info);
		case 13:
			var info = node.info;
			return this.analyseLoopKeyword(node,ctx,info);
		case 14:
			var info = node.info;
			return this.analyseLoopKeyword(node,ctx,info);
		case 17:
			var on = node.on;
			var field = node.field;
			var type = node.type;
			var info = node.info;
			return this.analyseStructAccessPost(node,on,field,type,ctx,info);
		case 22:
			var comp = node.components;
			var nodes = node.nodes;
			var info = node.info;
			return this.analyseVectorCreationPost(node,comp,nodes,ctx,info);
		default:
			return node;
		}
	}
	,execAtBody: function(body,ctx) {
		var newBody = [];
		var _g = 0;
		while(_g < body.length) {
			var node = body[_g];
			++_g;
			newBody.push(this.execAtNode(node,ctx));
		}
		return newBody;
	}
	,applyReplacements: function(body,replacements,exceptions) {
		body = body.slice();
		var _g = 0;
		var _g1 = body.length;
		while(_g < _g1) {
			var i = _g++;
			body[i] = this.applyReplacementsToNode(body[i],replacements,exceptions);
		}
		return body;
	}
	,checkTypeValidity: function(node) {
		var t = mnsl_analysis_MNSLAnalyser.getType(node);
		if(t._type != "Unknown" && !t._tempType && this._types.indexOf(t.toBaseString()) == -1) {
			this._context.emitError(mnsl_MNSLError.AnalyserUnknownType(t,node));
			return;
		}
	}
	,applyReplacementsToNode: function(node,replacements,exceptions) {
		exceptions = exceptions.slice();
		var checkReplacement = true;
		var _g = 0;
		while(_g < exceptions.length) {
			var e = exceptions[_g];
			++_g;
			if(Type.enumEq(e,node)) {
				checkReplacement = false;
			}
		}
		if(checkReplacement) {
			var _g = 0;
			while(_g < replacements.length) {
				var r = replacements[_g];
				++_g;
				if(r.node == node) {
					exceptions.push(node);
					node = r.to;
				}
			}
		}
		if(node == null) {
			this.checkTypeValidity(node);
			return null;
		}
		var e = Type.getEnum(node);
		var name = $hxEnums[node.__enum__].__constructs__[node._hx_index]._hx_name;
		var params = Type.enumParameters(node);
		var _g = 0;
		var _g1 = params.length;
		while(_g < _g1) {
			var i = _g++;
			var p = params[i];
			if(p == null) {
				continue;
			}
			if(((p) instanceof Array) && p[0] != null && js_Boot.__instanceof(p[0],mnsl_parser_MNSLNode)) {
				params[i] = this.applyReplacements(p,replacements,exceptions);
			} else if(js_Boot.__instanceof(p,mnsl_parser_MNSLNode)) {
				params[i] = this.applyReplacementsToNode(p,replacements,exceptions);
			}
		}
		var resNode = Type.createEnum(e,name,params);
		this.checkTypeValidity(resNode);
		return resNode;
	}
	,deferPostType: function(f) {
		this._deferPostType.push(f);
	}
	,checkBranchesOnBody: function(body,inFunction) {
		if(inFunction == null) {
			var _g = 0;
			while(_g < body.length) {
				var node = body[_g];
				++_g;
				this.checkBranchesOnNode(node,inFunction);
			}
			return;
		}
		if(inFunction.returnType.equals(new mnsl_analysis_MNSLType("Void"))) {
			var _g = 0;
			while(_g < body.length) {
				var node = body[_g];
				++_g;
				this.checkBranchesOnNode(node,inFunction);
			}
			return;
		}
		var _g = 0;
		while(_g < body.length) {
			var node = body[_g];
			++_g;
			this.checkBranchesOnNode(node,inFunction);
		}
	}
	,checkBranchesOnNode: function(node,inFunction) {
		if(node == null) {
			return;
		}
		switch(node._hx_index) {
		case 0:
			var name = node.name;
			var returnType = node.returnType;
			var args = node.$arguments;
			var body = node.body;
			var info = node.info;
			var func = new mnsl_analysis_MNSLAnalyserFunction(name,args,returnType,true,null);
			if(!func.returnType.equals(new mnsl_analysis_MNSLType("Void")) && !this.bodyHasReturn(body)) {
				this._context.emitError(mnsl_MNSLError.AnalyserMissingReturn(func,body));
			}
			this.checkBranchesOnBody(body,func);
			break;
		case 6:
			var cond = node.condition;
			var body = node.body;
			var info = node.info;
			this.checkBranchesOnBody(body,inFunction);
			break;
		case 7:
			var cond = node.condition;
			var body = node.body;
			var info = node.info;
			this.checkBranchesOnBody(body,inFunction);
			break;
		case 8:
			var body = node.body;
			var info = node.info;
			this.checkBranchesOnBody(body,inFunction);
			break;
		case 11:
			var cond = node.condition;
			var body = node.body;
			var info = node.info;
			this.checkBranchesOnBody(body,inFunction);
			break;
		case 12:
			var init = node.init;
			var condition = node.condition;
			var increment = node.increment;
			var body = node.body;
			var info = node.info;
			this.checkBranchesOnBody(body,inFunction);
			break;
		case 16:
			var body = node.body;
			var info = node.info;
			this.checkBranchesOnBody(body,inFunction);
			break;
		default:
			var params = Type.enumParameters(node);
			var _g = 0;
			var _g1 = params.length;
			while(_g < _g1) {
				var p = _g++;
				var pNode = params[p];
				if(pNode == null) {
					continue;
				}
				if(((pNode) instanceof Array) && pNode[0] != null && js_Boot.__instanceof(pNode[0],mnsl_parser_MNSLNode)) {
					this.checkBranchesOnBody(pNode,inFunction);
				} else if(js_Boot.__instanceof(pNode,mnsl_parser_MNSLNode)) {
					this.checkBranchesOnNode(pNode,inFunction);
				}
			}
		}
	}
	,bodyHasReturn: function(body) {
		var i = 0;
		while(i < body.length) {
			var node = body[i];
			switch(node._hx_index) {
			case 2:
				var _g = node.value;
				var _g1 = node.type;
				var _g2 = node.info;
				return true;
			case 6:
				var cond = node.condition;
				var ifBody = node.body;
				var info = node.info;
				var ifHasReturn = this.bodyHasReturn(ifBody);
				var hasElse = false;
				var allBranchesReturn = ifHasReturn;
				var j = i + 1;
				_hx_loop2: while(j < body.length) {
					var _g3 = body[j];
					switch(_g3._hx_index) {
					case 7:
						var _g4 = _g3.info;
						var elseCond = _g3.condition;
						var elseIfBody = _g3.body;
						var elseIfHasReturn = this.bodyHasReturn(elseIfBody);
						allBranchesReturn = allBranchesReturn && elseIfHasReturn;
						++j;
						break;
					case 8:
						var _g5 = _g3.info;
						var elseBody = _g3.body;
						hasElse = true;
						var elseHasReturn = this.bodyHasReturn(elseBody);
						allBranchesReturn = allBranchesReturn && elseHasReturn;
						++j;
						break _hx_loop2;
					default:
						break _hx_loop2;
					}
				}
				if(hasElse && allBranchesReturn) {
					return true;
				}
				i = j;
				continue;
			case 7:
				var _g6 = node.condition;
				var _g7 = node.body;
				var _g8 = node.info;
				++i;
				continue;
			case 8:
				var _g9 = node.body;
				var _g10 = node.info;
				++i;
				continue;
			case 16:
				var _g11 = node.info;
				var blockBody = node.body;
				if(this.bodyHasReturn(blockBody)) {
					return true;
				}
				break;
			default:
			}
			++i;
		}
		return false;
	}
	,checkForRecursion: function(body,inFunction) {
		var _g = 0;
		while(_g < body.length) {
			var node = body[_g];
			++_g;
			switch(node._hx_index) {
			case 0:
				var name = node.name;
				var returnType = node.returnType;
				var args = node.$arguments;
				var body1 = node.body;
				var info = node.info;
				if(inFunction != null && name == inFunction.name) {
					this._context.emitError(mnsl_MNSLError.AnalyserRecursiveFunction(name,[name],info));
				} else {
					this.checkForRecursion(body1,new mnsl_analysis_MNSLAnalyserFunction(name,args,returnType,true,null));
				}
				break;
			case 1:
				var name1 = node.name;
				var args1 = node.args;
				var returnType1 = node.returnType;
				var info1 = node.info;
				if(inFunction != null && name1 == inFunction.name) {
					this._context.emitError(mnsl_MNSLError.AnalyserRecursiveFunction(name1,[name1,name1],info1));
				}
				break;
			default:
				var params = Type.enumParameters(node);
				var _g1 = 0;
				var _g2 = params.length;
				while(_g1 < _g2) {
					var p = _g1++;
					var pNode = params[p];
					if(pNode == null) {
						continue;
					}
					if(((pNode) instanceof Array) && pNode[0] != null && js_Boot.__instanceof(pNode[0],mnsl_parser_MNSLNode)) {
						this.checkForRecursion(pNode,inFunction);
					} else if(js_Boot.__instanceof(pNode,mnsl_parser_MNSLNode)) {
						this.checkForRecursion([pNode],inFunction);
					}
				}
			}
		}
	}
	,run: function() {
		var res = this.execAtBody(this._ast,this._globalCtx);
		if(!this._solver.solve()) {
			var unresolvedConstraints = this._solver.getUnresolvedConstraints();
			var _g = 0;
			while(_g < unresolvedConstraints.length) {
				var c = unresolvedConstraints[_g];
				++_g;
				this._context.emitError(mnsl_MNSLError.AnalyserUnresolvedConstraint(c));
			}
		}
		var replacements = this._solver.getReplacements();
		res = this.applyReplacements(res,replacements,[]);
		var _g = 0;
		var _g1 = this._deferPostType;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			f();
		}
		this.checkBranchesOnBody(res,null);
		this.checkForRecursion(res,null);
		return res;
	}
	,__class__: mnsl_analysis_MNSLAnalyser
};
var mnsl_analysis_MNSLAnalyserContext = function() {
	this.functions = [];
	this.variables = [];
	this.currentFunction = null;
	this.currentIsLoop = false;
};
mnsl_analysis_MNSLAnalyserContext.__name__ = true;
mnsl_analysis_MNSLAnalyserContext.prototype = {
	copy: function() {
		var x = new mnsl_analysis_MNSLAnalyserContext();
		x.functions = this.functions.slice();
		x.variables = this.variables.slice();
		x.currentFunction = this.currentFunction;
		x.currentIsLoop = this.currentIsLoop;
		return x;
	}
	,findFunction: function(name,args,hasImpl) {
		if(hasImpl == null) {
			hasImpl = false;
		}
		var _g = 0;
		var _g1 = this.functions;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			if(f.name == name && f.args.length == args.length) {
				return f;
			}
		}
		return null;
	}
	,findVariable: function(name) {
		var _g = 0;
		var _g1 = this.variables;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			if(v.name == name) {
				return v;
			}
		}
		return null;
	}
	,__class__: mnsl_analysis_MNSLAnalyserContext
};
var mnsl_analysis_MNSLAnalyserFunction = function(name,args,returnType,hasImplementation,remap) {
	this.remap = null;
	this.hasImplementation = false;
	this.name = name;
	this.args = args;
	this.returnType = returnType;
	if(hasImplementation != null) {
		this.hasImplementation = hasImplementation;
	}
	if(remap != null) {
		this.remap = remap;
	}
};
mnsl_analysis_MNSLAnalyserFunction.__name__ = true;
mnsl_analysis_MNSLAnalyserFunction.prototype = {
	toString: function() {
		return "MNSLAnalyserFunction(" + this.name + ", " + this.args.toString() + ", " + this.returnType.toString() + ")" + (this.hasImplementation ? " hasImplementation" : "");
	}
	,__class__: mnsl_analysis_MNSLAnalyserFunction
};
var mnsl_analysis_MNSLAnalyserVariable = function(name,type,struct,fields) {
	this.fields = [];
	this.struct = false;
	this.name = name;
	this.type = type;
	if(struct != null) {
		this.struct = struct;
	}
	if(fields != null) {
		this.fields = fields;
	}
};
mnsl_analysis_MNSLAnalyserVariable.__name__ = true;
mnsl_analysis_MNSLAnalyserVariable.prototype = {
	toString: function() {
		return "MNSLAnalyserVariable(" + this.name + ", " + this.type.toString() + ")";
	}
	,__class__: mnsl_analysis_MNSLAnalyserVariable
};
var mnsl_analysis_MNSLConstraint = function(type,ofNode,mustBe,_optional,_isBinaryOp,_operationOperator,_mustBeOfNode) {
	this._mustBeOfNode = null;
	this._operationOperator = "";
	this._isBinaryOp = false;
	this._optional = false;
	this.type = type;
	this.ofNode = ofNode;
	this.mustBe = mustBe;
	if(_optional != null) {
		this._optional = _optional;
	}
	if(_isBinaryOp != null) {
		this._isBinaryOp = _isBinaryOp;
	}
	if(_operationOperator != null) {
		this._operationOperator = _operationOperator;
	}
	if(_mustBeOfNode != null) {
		this._mustBeOfNode = _mustBeOfNode;
	}
};
mnsl_analysis_MNSLConstraint.__name__ = true;
mnsl_analysis_MNSLConstraint.prototype = {
	toString: function() {
		return "MNSLConstraint(" + this.type.toHumanString() + " = " + this.mustBe.toHumanString() + " in " + Std.string(this.ofNode) + ")";
	}
	,__class__: mnsl_analysis_MNSLConstraint
};
var mnsl_analysis_MNSLFuncArg = function(name,type) {
	this.name = name;
	this.type = type;
};
mnsl_analysis_MNSLFuncArg.__name__ = true;
mnsl_analysis_MNSLFuncArg.prototype = {
	toString: function() {
		return this.name + "(" + Std.string(this.type) + ")";
	}
	,__class__: mnsl_analysis_MNSLFuncArg
};
var mnsl_analysis_MNSLReplaceCmd = function(node,to) {
	this.node = node;
	this.to = to;
};
mnsl_analysis_MNSLReplaceCmd.__name__ = true;
mnsl_analysis_MNSLReplaceCmd.prototype = {
	toString: function() {
		return "MNSLReplaceCmd(" + Std.string(this.node) + ", " + Std.string(this.to) + ")";
	}
	,__class__: mnsl_analysis_MNSLReplaceCmd
};
var mnsl_analysis_MNSLSolver = function(context) {
	this._replacements = [];
	this._constraints = [];
	this._context = context;
};
mnsl_analysis_MNSLSolver.__name__ = true;
mnsl_analysis_MNSLSolver.prototype = {
	addConstraint: function(c) {
		this._constraints.push(c);
	}
	,iter: function() {
		var _toRemove = [];
		var _g = 0;
		var _g1 = this._constraints;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			var tmp;
			var _this = c.type;
			if(_this._type != "Unknown" && !_this._tempType) {
				var _this1 = c.mustBe;
				tmp = _this1._type != "Unknown" && !_this1._tempType;
			} else {
				tmp = false;
			}
			if(tmp) {
				if(!c.type.equals(c.mustBe)) {
					if(this.tryCast(c)) {
						_toRemove.push(c);
						continue;
					}
					if(c._optional) {
						_toRemove.push(c);
						continue;
					}
					if(c._isBinaryOp) {
						this._context.emitError(mnsl_MNSLError.AnalyserInvalidBinop(c.type,c.mustBe,c._operationOperator,c));
					} else {
						this._context.emitError(mnsl_MNSLError.AnalyserMismatchingType(c));
					}
				}
			}
			var tmp1;
			var _this2 = c.type;
			if(!(_this2._type != "Unknown" && !_this2._tempType)) {
				var _this3 = c.mustBe;
				tmp1 = _this3._type != "Unknown" && !_this3._tempType;
			} else {
				tmp1 = false;
			}
			if(tmp1) {
				if(c.type.accepts(c.mustBe)) {
					c.type.setType(c.mustBe);
					c.type.setTempType(false);
					_toRemove.push(c);
				} else {
					var done = false;
					var _g2 = 0;
					var _g3 = c.type._limits;
					while(_g2 < _g3.length) {
						var l = _g3[_g2];
						++_g2;
						if(this.tryCastType(c.ofNode,c.type,l)) {
							c.type.setType(l);
							c.type.setTempType(false);
							_toRemove.push(c);
							break;
						}
					}
					if(done) {
						continue;
					}
					if(c._optional) {
						_toRemove.push(c);
						continue;
					}
					this._context.emitError(mnsl_MNSLError.AnalyserMismatchingEitherType(c.type._limits,c.ofNode));
				}
			}
			var tmp2;
			var _this4 = c.type;
			if(_this4._type != "Unknown" && !_this4._tempType) {
				var _this5 = c.mustBe;
				tmp2 = !(_this5._type != "Unknown" && !_this5._tempType);
			} else {
				tmp2 = false;
			}
			if(tmp2) {
				if(c.mustBe.accepts(c.type)) {
					c.mustBe.setType(c.type);
					c.mustBe.setTempType(false);
					_toRemove.push(c);
					continue;
				} else {
					var done1 = false;
					var _g4 = 0;
					var _g5 = c.mustBe._limits;
					while(_g4 < _g5.length) {
						var l1 = _g5[_g4];
						++_g4;
						if(this.tryCastType(c.ofNode,c.type,l1)) {
							c.mustBe.setType(l1);
							c.mustBe.setTempType(false);
							_toRemove.push(c);
							done1 = true;
							break;
						}
					}
					if(done1) {
						continue;
					}
					if(c._optional) {
						_toRemove.push(c);
						continue;
					}
					this._context.emitError(mnsl_MNSLError.AnalyserMismatchingEitherType(c.mustBe._limits,c.ofNode));
				}
			}
		}
		var _g = 0;
		while(_g < _toRemove.length) {
			var c = _toRemove[_g];
			++_g;
			HxOverrides.remove(this._constraints,c);
		}
		if(_toRemove.length > 0) {
			return true;
		}
		return false;
	}
	,tryCastType: function(node,from,to) {
		var c = new mnsl_analysis_MNSLConstraint(from,node,to,null,null,null,null);
		return this.tryCast(c);
	}
	,tryCast: function(c) {
		if(c.type._arrayBaseType != null || c.mustBe._arrayBaseType != null) {
			return false;
		}
		var tmp;
		var _this = c.type;
		if(_this._type == "Vec" + 2 || _this._type == "Vec" + 3 || _this._type == "Vec" + 4) {
			var _this = c.mustBe;
			tmp = _this._type == "Vec" + 2 || _this._type == "Vec" + 3 || _this._type == "Vec" + 4;
		} else {
			tmp = false;
		}
		if(tmp) {
			var componentsOfType;
			switch(c.type._type) {
			case "Vec2":
				componentsOfType = 2;
				break;
			case "Vec3":
				componentsOfType = 3;
				break;
			case "Vec4":
				componentsOfType = 4;
				break;
			default:
				componentsOfType = -1;
			}
			var componentsOfMustBe;
			switch(c.mustBe._type) {
			case "Vec2":
				componentsOfMustBe = 2;
				break;
			case "Vec3":
				componentsOfMustBe = 3;
				break;
			case "Vec4":
				componentsOfMustBe = 4;
				break;
			default:
				componentsOfMustBe = -1;
			}
			if(componentsOfType > componentsOfMustBe && c._isBinaryOp) {
				return true;
			}
			if(componentsOfMustBe < componentsOfType) {
				this._context.emitWarning(mnsl_MNSLWarning.ImplicitVectorTruncation(c.ofNode,componentsOfType,componentsOfMustBe));
			}
			this.addReplacement(new mnsl_analysis_MNSLReplaceCmd(c.ofNode,mnsl_parser_MNSLNode.VectorConversion(c.ofNode,componentsOfType,componentsOfMustBe)));
			return true;
		}
		var tmp;
		var _this = c.type;
		if(_this._type == "Float" || _this._type == "Int") {
			var _this = c.mustBe;
			tmp = _this._type == "Vec" + 2 || _this._type == "Vec" + 3 || _this._type == "Vec" + 4;
		} else {
			tmp = false;
		}
		if(tmp) {
			var componentsOfMustBe;
			switch(c.mustBe._type) {
			case "Vec2":
				componentsOfMustBe = 2;
				break;
			case "Vec3":
				componentsOfMustBe = 3;
				break;
			case "Vec4":
				componentsOfMustBe = 4;
				break;
			default:
				componentsOfMustBe = -1;
			}
			var _g = c.ofNode;
			var _g1 = [];
			var _g2 = 0;
			var _g3 = componentsOfMustBe;
			while(_g2 < _g3) {
				var i = _g2++;
				_g1.push(c.ofNode);
			}
			this.addReplacement(new mnsl_analysis_MNSLReplaceCmd(_g,mnsl_parser_MNSLNode.VectorCreation(componentsOfMustBe,_g1,null)));
			return true;
		}
		var _this = c.type;
		if((_this._type == "Float" || _this._type == "Int") && c.mustBe._type == "Bool") {
			this.addReplacement(new mnsl_analysis_MNSLReplaceCmd(c.ofNode,mnsl_parser_MNSLNode.BinaryOp(c.ofNode,mnsl_tokenizer_MNSLToken.NotEqual(null),mnsl_parser_MNSLNode.IntegerLiteralNode("0",null),new mnsl_analysis_MNSLType("Bool"),null)));
			return true;
		}
		var tmp;
		var _this = c.type;
		if(_this._type == "Float" || _this._type == "Int") {
			var _this = c.mustBe;
			tmp = _this._type == "Float" || _this._type == "Int";
		} else {
			tmp = false;
		}
		if(tmp) {
			if(c._isBinaryOp && c.type._type == "Float") {
				return true;
			}
			if(c.type._type == "Float" && c.mustBe._type == "Int") {
				this._context.emitWarning(mnsl_MNSLWarning.ImplicitFloatToInt(c.ofNode));
			}
			this.addReplacement(new mnsl_analysis_MNSLReplaceCmd(c.ofNode,mnsl_parser_MNSLNode.TypeCast(c.ofNode,c.type,c.mustBe)));
			return true;
		}
		return false;
	}
	,getUnresolvedConstraints: function() {
		var _tmp = [];
		var _g = 0;
		var _g1 = this._constraints;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			if(c.type._type == "Unknown" && c.mustBe._type == "Unknown") {
				_tmp.push(c);
			}
		}
		return _tmp;
	}
	,addReplacement: function(replacement) {
		var _g = 0;
		var _g1 = this._constraints;
		while(_g < _g1.length) {
			var existing = _g1[_g];
			++_g;
			if(Type.enumEq(existing.ofNode,replacement.node)) {
				var newType = mnsl_analysis_MNSLAnalyser.getType(replacement.to);
				existing.ofNode = replacement.to;
				existing.type = newType;
			}
			if(existing._mustBeOfNode != null && Type.enumEq(existing._mustBeOfNode,replacement.node)) {
				var newType1 = mnsl_analysis_MNSLAnalyser.getType(replacement.to);
				existing._mustBeOfNode = replacement.to;
				existing.mustBe = newType1;
			}
		}
		this._replacements.push(replacement);
	}
	,getReplacements: function() {
		return this._replacements;
	}
	,solve: function() {
		var changed = true;
		while(changed) changed = this.iter();
		return this.getUnresolvedConstraints().length == 0;
	}
	,__class__: mnsl_analysis_MNSLSolver
};
var mnsl_analysis_MNSLType = function(t,temp,limits) {
	if(temp == null) {
		temp = false;
	}
	this._arraySize = -1;
	this._tempType = temp;
	this._limits = limits != null ? limits : [];
	this._arrayBaseType = null;
	this.setTypeStrUnsafe(t);
};
mnsl_analysis_MNSLType.__name__ = true;
mnsl_analysis_MNSLType.Template = function(T,limits) {
	return new mnsl_analysis_MNSLType("Template<" + T + ">",true,limits);
};
mnsl_analysis_MNSLType.Array = function(T,size) {
	return new mnsl_analysis_MNSLType("Array<" + T + ", " + size + ">",false,[]);
};
mnsl_analysis_MNSLType.fromString = function(type) {
	return new mnsl_analysis_MNSLType(type);
};
mnsl_analysis_MNSLType.get_TUnknown = function() {
	return new mnsl_analysis_MNSLType("Unknown");
};
mnsl_analysis_MNSLType.get_TBool = function() {
	return new mnsl_analysis_MNSLType("Bool");
};
mnsl_analysis_MNSLType.get_TFloat = function() {
	return new mnsl_analysis_MNSLType("Float");
};
mnsl_analysis_MNSLType.get_TInt = function() {
	return new mnsl_analysis_MNSLType("Int");
};
mnsl_analysis_MNSLType.get_TMat2 = function() {
	return new mnsl_analysis_MNSLType("Mat2");
};
mnsl_analysis_MNSLType.get_TMat3 = function() {
	return new mnsl_analysis_MNSLType("Mat3");
};
mnsl_analysis_MNSLType.get_TMat4 = function() {
	return new mnsl_analysis_MNSLType("Mat4");
};
mnsl_analysis_MNSLType.get_TVec2 = function() {
	return new mnsl_analysis_MNSLType("Vec2");
};
mnsl_analysis_MNSLType.get_TVec3 = function() {
	return new mnsl_analysis_MNSLType("Vec3");
};
mnsl_analysis_MNSLType.get_TVec4 = function() {
	return new mnsl_analysis_MNSLType("Vec4");
};
mnsl_analysis_MNSLType.get_TVoid = function() {
	return new mnsl_analysis_MNSLType("Void");
};
mnsl_analysis_MNSLType.get_TString = function() {
	return new mnsl_analysis_MNSLType("String");
};
mnsl_analysis_MNSLType.get_TSampler = function() {
	return new mnsl_analysis_MNSLType("Sampler");
};
mnsl_analysis_MNSLType.get_TCubeSampler = function() {
	return new mnsl_analysis_MNSLType("CubeSampler");
};
mnsl_analysis_MNSLType.get_TCTValue = function() {
	return new mnsl_analysis_MNSLType("CTValue");
};
mnsl_analysis_MNSLType.prototype = {
	getLimits: function() {
		return this._limits;
	}
	,setLimits: function(limits) {
		this._limits = limits;
	}
	,hasLimits: function() {
		return this._limits.length > 0;
	}
	,setArrayBaseType: function(base) {
		this._arrayBaseType = base;
	}
	,setArraySize: function(size) {
		this._arraySize = size;
	}
	,getArraySize: function() {
		return this._arraySize;
	}
	,getArrayBaseType: function() {
		var tmp = this._arrayBaseType;
		if(tmp != null) {
			return tmp;
		} else {
			return this;
		}
	}
	,isArray: function() {
		return this._arrayBaseType != null;
	}
	,accepts: function(t) {
		if(this._limits.length <= 0) {
			return true;
		}
		var _g = 0;
		var _g1 = this._limits;
		while(_g < _g1.length) {
			var l = _g1[_g];
			++_g;
			if(l.equals(t)) {
				return true;
			}
		}
		return false;
	}
	,setTypeStrUnsafe: function(type) {
		if(StringTools.startsWith(type,"Array<") && StringTools.endsWith(type,">")) {
			var baseTypeContent = HxOverrides.substr(type,6,type.length - 7);
			var parts = StringTools.replace(baseTypeContent," ","").split(",");
			if(parts.length > 0) {
				this._arrayBaseType = new mnsl_analysis_MNSLType(parts[0]);
			}
			if(parts.length > 1) {
				var tmp = Std.parseInt(parts[1]);
				this._arraySize = tmp != null ? tmp : -1;
			}
		}
		this._type = type;
	}
	,setType: function(type) {
		this.setTypeStrUnsafe(type.toString());
	}
	,equals: function(type) {
		return this._type == type._type;
	}
	,setTempType: function(temp) {
		this._tempType = temp;
	}
	,isDefined: function() {
		if(this._type != "Unknown") {
			return !this._tempType;
		} else {
			return false;
		}
	}
	,isUnknown: function() {
		return this._type == "Unknown";
	}
	,isFloat: function() {
		return this._type == "Float";
	}
	,isNumerical: function() {
		if(this._type != "Float") {
			return this._type == "Int";
		} else {
			return true;
		}
	}
	,isInt: function() {
		return this._type == "Int";
	}
	,isBool: function() {
		return this._type == "Bool";
	}
	,isTemplate: function() {
		if(StringTools.startsWith(this._type,"Template<")) {
			return StringTools.endsWith(this._type,">");
		} else {
			return false;
		}
	}
	,getTemplateName: function() {
		if(!(StringTools.startsWith(this._type,"Template<") && StringTools.endsWith(this._type,">"))) {
			return null;
		}
		return HxOverrides.substr(this._type,9,this._type.length - 10);
	}
	,isVectorWithComponents: function(components) {
		return this._type == "Vec" + components;
	}
	,getVectorComponents: function() {
		switch(this._type) {
		case "Vec2":
			return 2;
		case "Vec3":
			return 3;
		case "Vec4":
			return 4;
		default:
			return -1;
		}
	}
	,isVector: function() {
		if(!(this._type == "Vec" + 2 || this._type == "Vec" + 3)) {
			return this._type == "Vec" + 4;
		} else {
			return true;
		}
	}
	,isMatrixWithEqualSize: function(size) {
		return this._type == "Mat" + size;
	}
	,getMatrixWidth: function() {
		switch(this._type) {
		case "Mat2":
			return 2;
		case "Mat3":
			return 3;
		case "Mat4":
			return 4;
		default:
			return -1;
		}
	}
	,getMatrixHeight: function() {
		switch(this._type) {
		case "Mat2":
			return 2;
		case "Mat3":
			return 3;
		case "Mat4":
			return 4;
		default:
			return -1;
		}
	}
	,isMatrix: function() {
		if(!(this._type == "Mat" + 2 || this._type == "Mat" + 3)) {
			return this._type == "Mat" + 4;
		} else {
			return true;
		}
	}
	,isBoolean: function() {
		return this._type == "Bool";
	}
	,toString: function() {
		return this._type;
	}
	,toBaseString: function() {
		if(StringTools.startsWith(this._type,"Template<") && StringTools.endsWith(this._type,">")) {
			if(!(StringTools.startsWith(this._type,"Template<") && StringTools.endsWith(this._type,">"))) {
				return null;
			} else {
				return HxOverrides.substr(this._type,9,this._type.length - 10);
			}
		}
		if(this._arrayBaseType != null) {
			var tmp = this._arrayBaseType;
			return (tmp != null ? tmp : this).toBaseString();
		}
		return this._type;
	}
	,toHumanString: function() {
		return "T" + this._type + (this._tempType ? " (temp)" : "");
	}
	,copy: function() {
		return new mnsl_analysis_MNSLType(this._type,this._tempType);
	}
	,__class__: mnsl_analysis_MNSLType
};
var mnsl_glsl_MNSLGLSLConfig = function(version,versionDirective,useAttributeAndVaryingKeywords,usePrecision) {
	this.usePrecision = null;
	this.useAttributeAndVaryingKeywords = null;
	this.version = version;
	this.versionDirective = versionDirective;
	if(useAttributeAndVaryingKeywords != null) {
		this.useAttributeAndVaryingKeywords = useAttributeAndVaryingKeywords;
	}
	if(usePrecision != null) {
		this.usePrecision = usePrecision;
	}
};
mnsl_glsl_MNSLGLSLConfig.__name__ = true;
mnsl_glsl_MNSLGLSLConfig.prototype = {
	__class__: mnsl_glsl_MNSLGLSLConfig
};
var mnsl_glsl_MNSLGLSLPrinter = function(context,config) {
	var _g = new haxe_ds_StringMap();
	_g.h["VertexID"] = "gl_VertexID";
	_g.h["InstanceID"] = "gl_InstanceID";
	_g.h["BaseVertex"] = "gl_BaseVertex";
	_g.h["BaseInstance"] = "gl_BaseInstance";
	_g.h["FragCoord"] = "gl_FragCoord";
	_g.h["FrontFacing"] = "gl_FrontFacing";
	_g.h["FragDepth"] = "gl_FragDepth";
	this._internalInputStruct = _g;
	var _g = new haxe_ds_StringMap();
	_g.h["Position"] = "gl_Position";
	_g.h["PointSize"] = "gl_PointSize";
	this._internalOutputStruct = _g;
	var _g = new haxe_ds_StringMap();
	_g.h["float"] = "mediump";
	_g.h["int"] = "mediump";
	this._defaultPrecision = _g;
	var _g = new haxe_ds_StringMap();
	_g.h["Void"] = "void";
	_g.h["Int"] = "int";
	_g.h["Float"] = "float";
	_g.h["Vec2"] = "vec2";
	_g.h["Vec3"] = "vec3";
	_g.h["Vec4"] = "vec4";
	_g.h["Mat2"] = "mat2";
	_g.h["Mat3"] = "mat3";
	_g.h["Mat4"] = "mat4";
	_g.h["Bool"] = "bool";
	_g.h["Sampler"] = "sampler2D";
	_g.h["CubeSampler"] = "samplerCube";
	this._types = _g;
	mnsl_MNSLPrinter.call(this,context);
	this._config = config;
	var versionInt = config.version;
	var tmp = config.useAttributeAndVaryingKeywords;
	config.useAttributeAndVaryingKeywords = tmp != null ? tmp : versionInt < 130;
	var tmp = config.usePrecision;
	config.usePrecision = tmp != null ? tmp : config.versionDirective == "es";
};
mnsl_glsl_MNSLGLSLPrinter.__name__ = true;
mnsl_glsl_MNSLGLSLPrinter.__super__ = mnsl_MNSLPrinter;
mnsl_glsl_MNSLGLSLPrinter.prototype = $extend(mnsl_MNSLPrinter.prototype,{
	printNodeChildren: function(children) {
		var _g = 0;
		while(_g < children.length) {
			var child = children[_g];
			++_g;
			this.printNode(child);
		}
	}
	,printNode: function(node) {
		var _gthis = this;
		if(node == null) {
			return;
		}
		switch(node._hx_index) {
		case 0:
			var name = node.name;
			var returnType = node.returnType;
			var $arguments = node.$arguments;
			var body = node.body;
			var info = node.info;
			var tmp = returnType._arrayBaseType != null ? "" + this.getTypeStr(returnType) + "[" + returnType._arraySize + "]" : this.getTypeStr(returnType);
			var result = new Array($arguments.length);
			var _g = 0;
			var _g1 = $arguments.length;
			while(_g < _g1) {
				var i = _g++;
				var arg = $arguments[i];
				result[i] = _gthis.getTypeStr(arg.type) + " " + arg.name + (arg.type._arrayBaseType != null ? "[" + arg.type._arraySize + "]" : "");
			}
			this.printlnIndented("{0} {1}({2}) {",tmp,name,result.join(", "));
			this.increaseIndent();
			this.printNodeChildren(body);
			this.decreaseIndent();
			this.printlnIndented("}\n");
			break;
		case 1:
			var name = node.name;
			var args = node.args;
			var type = node.returnType;
			var info = node.info;
			this.printIndented("{0}(",name);
			var _g = 0;
			while(_g < args.length) {
				var arg = args[_g];
				++_g;
				this.printNode(arg);
				if(arg != args[args.length - 1]) {
					this.print(", ");
				}
			}
			this.println(")" + (this._inline ? "" : ";"));
			break;
		case 2:
			var node1 = node.value;
			var type = node.type;
			var info = node.info;
			var nodeIsVoid;
			if(node1 != null) {
				if(node1._hx_index == 20) {
					var _g = node1.info;
					nodeIsVoid = true;
				} else {
					nodeIsVoid = false;
				}
			} else {
				nodeIsVoid = true;
			}
			this.printIndented("return" + (nodeIsVoid ? "" : " "));
			if(node1 != null) {
				this.enableInline();
				this.printNode(node1);
				this.disableInline();
			}
			this.println(";");
			break;
		case 3:
			var name = node.name;
			var type = node.type;
			var value = node.value;
			var info = node.info;
			if(value == null) {
				this.printlnIndented("{0} {1};",this.getTypeStr(type),name + (type._arrayBaseType != null ? "[" + type._arraySize + "]" : ""));
			} else {
				this.printIndented("{0} {1} = ",this.getTypeStr(type),name + (type._arrayBaseType != null ? "[" + type._arraySize + "]" : ""));
				this.enableInline();
				this.printNode(value);
				this.disableInline();
				this.removeLastSemicolon();
				this.println(";");
			}
			break;
		case 4:
			var name = node.name;
			var value = node.value;
			var info = node.info;
			this.printIndented("");
			this.printNode(name);
			this.print(" = ");
			this.enableInline();
			this.printNode(value);
			this.disableInline();
			this.removeLastSemicolon();
			this.println(";");
			break;
		case 5:
			var name = node.name;
			var type = node.type;
			var info = node.info;
			this.print(name);
			break;
		case 6:
			var condition = node.condition;
			var body = node.body;
			var info = node.info;
			this.printIndented("if (");
			this.enableInline();
			this.printNode(condition);
			this.disableInline();
			this.println(") {");
			this.increaseIndent();
			this.printNodeChildren(body);
			this.decreaseIndent();
			this.printlnIndented("}");
			break;
		case 7:
			var condition = node.condition;
			var body = node.body;
			var info = node.info;
			this.removeLastNewLine();
			this.print(" else if (");
			this.enableInline();
			this.printNode(condition);
			this.disableInline();
			this.println(") {");
			this.increaseIndent();
			this.printNodeChildren(body);
			this.decreaseIndent();
			this.printlnIndented("}");
			break;
		case 8:
			var body = node.body;
			var info = node.info;
			this.removeLastNewLine();
			this.println(" else {");
			this.increaseIndent();
			this.printNodeChildren(body);
			this.decreaseIndent();
			this.printlnIndented("}");
			break;
		case 9:
			var left = node.left;
			var op = node.op;
			var right = node.right;
			var type = node.type;
			var info = node.info;
			this.enableInline();
			this.printNode(left);
			this.print(" " + this.toOperationStr(op) + " ");
			this.printNode(right);
			this.disableInline();
			break;
		case 10:
			var op = node.op;
			var node1 = node.right;
			var info = node.info;
			this.enableInline();
			this.print(this.toOperationStr(op));
			this.printNode(node1);
			this.disableInline();
			break;
		case 11:
			var condition = node.condition;
			var body = node.body;
			var info = node.info;
			this.printIndented("while (");
			this.enableInline();
			this.printNode(condition);
			this.disableInline();
			this.println(") {");
			this.increaseIndent();
			this.printNodeChildren(body);
			this.decreaseIndent();
			this.printlnIndented("}");
			break;
		case 12:
			var init = node.init;
			var condition = node.condition;
			var increment = node.increment;
			var body = node.body;
			var info = node.info;
			this.printIndented("for (");
			this.enableInline();
			if(init != null) {
				this.printNode(init);
			}
			this.removeLastSemicolon();
			this.print("; ");
			if(condition != null) {
				this.printNode(condition);
			}
			this.removeLastSemicolon();
			this.print("; ");
			if(increment != null) {
				this.printNode(increment);
			}
			this.removeLastSemicolon();
			this.disableInline();
			this.println(") {");
			this.increaseIndent();
			this.printNodeChildren(body);
			this.decreaseIndent();
			this.printlnIndented("}");
			break;
		case 13:
			var info = node.info;
			this.printlnIndented("break;");
			break;
		case 14:
			var info = node.info;
			this.printlnIndented("continue;");
			break;
		case 15:
			var node1 = node.node;
			var info = node.info;
			this.print("(");
			this.enableInline();
			this.printNode(node1);
			this.disableInline();
			this.print(")");
			break;
		case 16:
			var body = node.body;
			var info = node.info;
			this.printNodeChildren(body);
			break;
		case 17:
			var on = node.on;
			var field = node.field;
			var type = node.type;
			var info = node.info;
			var tmp;
			if(on._hx_index == 5) {
				var _g = on.type;
				var _g = on.info;
				tmp = on.name == "output";
			} else {
				tmp = false;
			}
			if(tmp) {
				if(Object.prototype.hasOwnProperty.call(this._internalOutputStruct.h,field)) {
					this.print(this._internalOutputStruct.h[field]);
					return;
				}
				var _g = 0;
				var _g1 = this._context.getShaderData();
				while(_g < _g1.length) {
					var data = _g1[_g];
					++_g;
					if(data.name == field && data.kind == mnsl_parser_MNSLShaderDataKind.Output) {
						this.print("out_" + data.name);
						return;
					}
				}
			}
			var tmp;
			if(on._hx_index == 5) {
				var _g = on.type;
				var _g = on.info;
				tmp = on.name == "input";
			} else {
				tmp = false;
			}
			if(tmp) {
				if(Object.prototype.hasOwnProperty.call(this._internalInputStruct.h,field)) {
					this.print(this._internalInputStruct.h[field]);
					return;
				}
				var _g = 0;
				var _g1 = this._context.getShaderData();
				while(_g < _g1.length) {
					var data = _g1[_g];
					++_g;
					if(data.name == field && data.kind == mnsl_parser_MNSLShaderDataKind.Input) {
						this.print("in_" + data.name);
						return;
					}
				}
			}
			var tmp;
			if(on._hx_index == 5) {
				var _g = on.type;
				var _g = on.info;
				tmp = on.name == "uniform";
			} else {
				tmp = false;
			}
			if(tmp) {
				var _g = 0;
				var _g1 = this._context.getShaderData();
				while(_g < _g1.length) {
					var data = _g1[_g];
					++_g;
					if(data.name == field && data.kind == mnsl_parser_MNSLShaderDataKind.Uniform) {
						this.print("u_" + data.name);
						return;
					}
				}
			}
			this.printNode(on);
			this.print(".");
			this.print(field);
			break;
		case 18:
			var on = node.on;
			var index = node.index;
			var info = node.info;
			this.printNode(on);
			this.print("[");
			this.printNode(index);
			this.print("]");
			break;
		case 19:
			var on = node.on;
			var from = node.from;
			var to = node.to;
			if(from._arrayBaseType != null || to._arrayBaseType != null) {
				throw haxe_Exception.thrown("Type casting of arrays is not supported!");
			}
			this.print(this.getTypeStr(to));
			this.print("(");
			this.enableInline();
			this.printNode(on);
			this.disableInline();
			this.print(")");
			break;
		case 20:
			var info = node.info;
			return;
		case 22:
			var components = node.components;
			var nodes = node.nodes;
			var info = node.info;
			this.print("vec");
			this.print("" + components);
			this.print("(");
			var _g = 0;
			var _g1 = nodes.length;
			while(_g < _g1) {
				var i = _g++;
				this.enableInline();
				this.printNode(nodes[i]);
				this.disableInline();
				if(i < nodes.length - 1) {
					this.print(", ");
				}
			}
			this.print(")");
			break;
		case 23:
			var node1 = node.on;
			var fromComp = node.fromComponents;
			var toComp = node.toComponents;
			if(fromComp == toComp) {
				this.enableInline();
				this.printNode(node1);
				this.disableInline();
			} else if(fromComp < toComp) {
				this.print("vec");
				this.print("" + toComp);
				this.print("(");
				this.enableInline();
				this.printNode(node1);
				this.disableInline();
				var _g = fromComp;
				var _g1 = toComp;
				while(_g < _g1) {
					var i = _g++;
					this.print(", ");
					if(i == 2) {
						this.print("0.0");
					} else {
						this.print("1.0");
					}
				}
				this.print(")");
			} else {
				this.print("vec");
				this.print("" + toComp);
				this.print("(");
				this.enableInline();
				this.printNode(node1);
				this.disableInline();
				this.print(")");
			}
			break;
		case 24:
			var value = node.value;
			var info = node.info;
			this.print(value);
			break;
		case 25:
			var value = node.value;
			var info = node.info;
			this.print(value);
			break;
		case 27:
			var value = node.value;
			var info = node.info;
			this.print(value ? "1" : "0");
			break;
		default:
			throw haxe_Exception.thrown("Unknown node type: " + Std.string(node));
		}
	}
	,toOperationStr: function(op) {
		switch(op._hx_index) {
		case 14:
			var _g = op.info;
			return "-";
		case 15:
			var _g = op.info;
			return "+";
		case 17:
			var _g = op.info;
			return "/";
		case 18:
			var _g = op.info;
			return "*";
		case 19:
			var _g = op.info;
			return "%";
		case 22:
			var _g = op.info;
			return "==";
		case 25:
			var _g = op.info;
			return "&&";
		case 26:
			var _g = op.info;
			return "||";
		case 27:
			var _g = op.info;
			return "<";
		case 28:
			var _g = op.info;
			return ">";
		case 29:
			var _g = op.info;
			return "<=";
		case 30:
			var _g = op.info;
			return ">=";
		case 31:
			var _g = op.info;
			return "!=";
		case 32:
			var _g = op.info;
			return "!";
		default:
			throw haxe_Exception.thrown("Unknown operation: " + Std.string(op));
		}
	}
	,run: function() {
		this.println("#version {0} {1}",this._config.version,this._config.versionDirective);
		this.println("");
		if(this._config.usePrecision) {
			var printed_h = Object.create(null);
			var h = this._types.h;
			var type_h = h;
			var type_keys = Object.keys(h);
			var type_length = type_keys.length;
			var type_current = 0;
			while(type_current < type_length) {
				var type = type_h[type_keys[type_current++]];
				if(Object.prototype.hasOwnProperty.call(this._defaultPrecision.h,type) && !Object.prototype.hasOwnProperty.call(printed_h,type)) {
					this.println("precision {0} {1};",this._defaultPrecision.h[type],type);
					printed_h[type] = true;
				}
			}
			this.println("");
		}
		var dataOutputLength = 0;
		var _g = 0;
		var _g1 = this._context.getShaderData();
		while(_g < _g1.length) {
			var data = _g1[_g];
			++_g;
			switch(data.kind._hx_index) {
			case 0:
				if(Object.prototype.hasOwnProperty.call(this._internalInputStruct.h,data.name)) {
					continue;
				}
				++dataOutputLength;
				if(this._config.useAttributeAndVaryingKeywords) {
					this.println("attribute {0} in_{1};",this.getTypeStr(data.type),data.name);
				} else {
					this.println("in {0} in_{1};",this.getTypeStr(data.type),data.name);
				}
				break;
			case 1:
				if(Object.prototype.hasOwnProperty.call(this._internalOutputStruct.h,data.name)) {
					continue;
				}
				++dataOutputLength;
				if(this._config.useAttributeAndVaryingKeywords) {
					this.println("varying {0} out_{1};",this.getTypeStr(data.type),data.name);
				} else {
					this.println("out {0} out_{1};",this.getTypeStr(data.type),data.name);
				}
				break;
			case 2:
				++dataOutputLength;
				if(data.type._arrayBaseType != null) {
					var _this = data.type;
					var tmp = _this._arrayBaseType;
					this.println("uniform {0} u_{1}[{2}];",this.getTypeStr(tmp != null ? tmp : _this),data.name,data.type._arraySize);
				} else {
					var _this1 = data.type;
					var tmp1 = _this1._arrayBaseType;
					this.println("uniform {0} u_{1};",this.getTypeStr(tmp1 != null ? tmp1 : _this1),data.name);
				}
				break;
			}
		}
		if(dataOutputLength > 0) {
			this.println("");
		}
		this.printNodeChildren(this._ast);
	}
	,getTypeStr: function(type) {
		var this1 = this._types;
		var key = type.toBaseString();
		return this1.h[key];
	}
	,__class__: mnsl_glsl_MNSLGLSLPrinter
});
var mnsl_optimiser_MNSLOptimiser = function(context,ast) {
	this.plugins = [];
	this.context = context;
	this.ast = ast;
};
mnsl_optimiser_MNSLOptimiser.__name__ = true;
mnsl_optimiser_MNSLOptimiser.prototype = {
	addPlugin: function(plugin) {
		this.plugins.push(plugin);
	}
	,run: function() {
		return this.runOnBody(this.ast);
	}
	,runOnBody: function(body) {
		var optimizedBody = [];
		var _g = 0;
		while(_g < body.length) {
			var child = body[_g];
			++_g;
			optimizedBody.push(this.runOnNode(child));
		}
		return optimizedBody;
	}
	,runOnNode: function(node) {
		var params = Type.enumParameters(node);
		var _g = 0;
		var _g1 = this.plugins;
		while(_g < _g1.length) {
			var plugin = _g1[_g];
			++_g;
			if(plugin.canOptimise(node,this)) {
				var result = plugin.optimise(node,params,this);
				if(result != null) {
					node = result;
					params = Type.enumParameters(node);
				}
			}
		}
		var _g = 0;
		var _g1 = params.length;
		while(_g < _g1) {
			var pIdx = _g++;
			var p = params[pIdx];
			if(((p) instanceof Array) && p[0] != null && js_Boot.__instanceof(p[0],mnsl_parser_MNSLNode)) {
				params[pIdx] = this.runOnBody(p);
			} else if(js_Boot.__instanceof(p,mnsl_parser_MNSLNode)) {
				params[pIdx] = this.runOnNode(p);
			}
		}
		return Type.createEnum(Type.getEnum(node),$hxEnums[node.__enum__].__constructs__[node._hx_index]._hx_name,params);
	}
	,__class__: mnsl_optimiser_MNSLOptimiser
};
var mnsl_optimiser_MNSLOptimiserPlugin = function(onNode) {
	this._on = onNode;
};
mnsl_optimiser_MNSLOptimiserPlugin.__name__ = true;
mnsl_optimiser_MNSLOptimiserPlugin.prototype = {
	onRun: function(node,params,optimizer) {
		return node;
	}
	,typeOf: function(node) {
		return mnsl_analysis_MNSLAnalyser.getType(node).copy();
	}
	,allMatchValue: function(values) {
		return this.allMatchFunction(values,function(value) {
			return value == values[0];
		});
	}
	,allMatchFunction: function(values,func) {
		if(values.length == 0) {
			return true;
		}
		var _g = 0;
		while(_g < values.length) {
			var value = values[_g];
			++_g;
			if(!func(value)) {
				return false;
			}
		}
		return true;
	}
	,canOptimise: function(node,optimizer) {
		var e = this._on;
		return $hxEnums[node.__enum__].__constructs__[node._hx_index]._hx_name == $hxEnums[e.__enum__].__constructs__[e._hx_index]._hx_name;
	}
	,optimise: function(node,params,optimizer) {
		return this.onRun(node,params,optimizer);
	}
	,__class__: mnsl_optimiser_MNSLOptimiserPlugin
};
var mnsl_optimiser_impl_MNSLOptimiseScalarVectorInit = function() {
	mnsl_optimiser_MNSLOptimiserPlugin.call(this,mnsl_parser_MNSLNode.VectorCreation(0,null,null));
};
mnsl_optimiser_impl_MNSLOptimiseScalarVectorInit.__name__ = true;
mnsl_optimiser_impl_MNSLOptimiseScalarVectorInit.__super__ = mnsl_optimiser_MNSLOptimiserPlugin;
mnsl_optimiser_impl_MNSLOptimiseScalarVectorInit.prototype = $extend(mnsl_optimiser_MNSLOptimiserPlugin.prototype,{
	onRun: function(node,params,optimizer) {
		var components = params[0];
		var values = params[1];
		var _g = [];
		var _g1 = 0;
		while(_g1 < values.length) {
			var v = values[_g1];
			++_g1;
			_g.push(Std.string(v));
		}
		var valuesString = _g;
		if(this.allMatchValue(valuesString) && values.length > 1) {
			return mnsl_parser_MNSLNode.VectorCreation(components,[values[0]],null);
		}
		return node;
	}
	,__class__: mnsl_optimiser_impl_MNSLOptimiseScalarVectorInit
});
var mnsl_optimiser_impl_MNSLOptimiseSwizzleAccess = function() {
	mnsl_optimiser_MNSLOptimiserPlugin.call(this,mnsl_parser_MNSLNode.VectorCreation(0,null,null));
};
mnsl_optimiser_impl_MNSLOptimiseSwizzleAccess.__name__ = true;
mnsl_optimiser_impl_MNSLOptimiseSwizzleAccess.__super__ = mnsl_optimiser_MNSLOptimiserPlugin;
mnsl_optimiser_impl_MNSLOptimiseSwizzleAccess.prototype = $extend(mnsl_optimiser_MNSLOptimiserPlugin.prototype,{
	onRun: function(node,params,optimizer) {
		var components = params[0];
		var values = params[1];
		if(!this.allMatchFunction(values,function(node) {
			return $hxEnums[node.__enum__].__constructs__[node._hx_index]._hx_name == "StructAccess";
		})) {
			return node;
		}
		var firstNode = values[0];
		var firstOn = Type.enumParameters(firstNode)[0];
		var firstType = Type.enumParameters(firstNode)[2];
		var firstInfo = Type.enumParameters(firstNode)[3];
		if(values.length < 2) {
			return node;
		}
		var fields = [];
		if(!this.allMatchFunction(values,function(node) {
			var params = Type.enumParameters(node);
			var on = params[0];
			fields.push(params[1]);
			return Std.string(on) == Std.string(firstOn);
		})) {
			return node;
		}
		if(!this.allMatchFunction(fields,function(field) {
			if(!(field == "x" || field == "y" || field == "z")) {
				return field == "w";
			} else {
				return true;
			}
		})) {
			return node;
		}
		return mnsl_parser_MNSLNode.StructAccess(firstOn,fields.join(""),firstType,firstInfo);
	}
	,__class__: mnsl_optimiser_impl_MNSLOptimiseSwizzleAccess
});
var mnsl_optimiser_impl_MNSLOptimiseSwizzleAssign = function() {
	mnsl_optimiser_MNSLOptimiserPlugin.call(this,mnsl_parser_MNSLNode.Block(null,null));
};
mnsl_optimiser_impl_MNSLOptimiseSwizzleAssign.__name__ = true;
mnsl_optimiser_impl_MNSLOptimiseSwizzleAssign.__super__ = mnsl_optimiser_MNSLOptimiserPlugin;
mnsl_optimiser_impl_MNSLOptimiseSwizzleAssign.prototype = $extend(mnsl_optimiser_MNSLOptimiserPlugin.prototype,{
	onRun: function(node,params,optimizer) {
		var onArr = [];
		var vOnArr = [];
		var fieldLeftArr = [];
		var fieldRightArr = [];
		var optimInfo = null;
		if(!this.allMatchFunction(params[0],function(node) {
			if(node._hx_index == 4) {
				var _g = node.name;
				if(_g._hx_index == 17) {
					var on = _g.on;
					var field = _g.field;
					var type = _g.type;
					var stuctInfo = _g.info;
					var value = node.value;
					var info = node.info;
					if(optimInfo == null) {
						optimInfo = info;
					}
					onArr.push(on);
					fieldLeftArr.push(field);
					if(field != "x" && field != "y" && field != "z" && field != "w") {
						return false;
					}
					var _this = mnsl_analysis_MNSLAnalyser.getType(on);
					if(!(_this._type == "Vec" + 2 || _this._type == "Vec" + 3 || _this._type == "Vec" + 4)) {
						return false;
					}
					if(value._hx_index == 17) {
						var vOn = value.on;
						var vField = value.field;
						var vType = value.type;
						var vInfo = value.info;
						if(vField != "x" && vField != "y" && vField != "z" && vField != "w") {
							return false;
						}
						var _this = mnsl_analysis_MNSLAnalyser.getType(vOn);
						if(!(_this._type == "Vec" + 2 || _this._type == "Vec" + 3 || _this._type == "Vec" + 4)) {
							return false;
						}
						vOnArr.push(vOn);
						fieldRightArr.push(vField);
					} else {
						return false;
					}
					return true;
				} else {
					return false;
				}
			} else {
				return false;
			}
		})) {
			return node;
		}
		if(onArr.length == 0) {
			return node;
		}
		var firstOn = onArr[0];
		if(!this.allMatchFunction(onArr,function(node) {
			return Std.string(firstOn) == Std.string(node);
		})) {
			return node;
		}
		if(vOnArr.length == 0) {
			return node;
		}
		var firstVOn = vOnArr[0];
		if(!this.allMatchFunction(vOnArr,function(node) {
			return Std.string(firstVOn) == Std.string(node);
		})) {
			return node;
		}
		return mnsl_parser_MNSLNode.VariableAssign(mnsl_parser_MNSLNode.StructAccess(firstOn,fieldLeftArr.join(""),mnsl_analysis_MNSLAnalyser.getType(firstOn),null),firstVOn,optimInfo);
	}
	,__class__: mnsl_optimiser_impl_MNSLOptimiseSwizzleAssign
});
var mnsl_parser_MNSLNode = $hxEnums["mnsl.parser.MNSLNode"] = { __ename__:true,__constructs__:null
	,FunctionDecl: ($_=function(name,returnType,$arguments,body,info) { return {_hx_index:0,name:name,returnType:returnType,$arguments:$arguments,body:body,info:info,__enum__:"mnsl.parser.MNSLNode",toString:$estr}; },$_._hx_name="FunctionDecl",$_.__params__ = ["name","returnType","$arguments","body","info"],$_)
	,FunctionCall: ($_=function(name,args,returnType,info) { return {_hx_index:1,name:name,args:args,returnType:returnType,info:info,__enum__:"mnsl.parser.MNSLNode",toString:$estr}; },$_._hx_name="FunctionCall",$_.__params__ = ["name","args","returnType","info"],$_)
	,Return: ($_=function(value,type,info) { return {_hx_index:2,value:value,type:type,info:info,__enum__:"mnsl.parser.MNSLNode",toString:$estr}; },$_._hx_name="Return",$_.__params__ = ["value","type","info"],$_)
	,VariableDecl: ($_=function(name,type,value,info) { return {_hx_index:3,name:name,type:type,value:value,info:info,__enum__:"mnsl.parser.MNSLNode",toString:$estr}; },$_._hx_name="VariableDecl",$_.__params__ = ["name","type","value","info"],$_)
	,VariableAssign: ($_=function(name,value,info) { return {_hx_index:4,name:name,value:value,info:info,__enum__:"mnsl.parser.MNSLNode",toString:$estr}; },$_._hx_name="VariableAssign",$_.__params__ = ["name","value","info"],$_)
	,Identifier: ($_=function(name,type,info) { return {_hx_index:5,name:name,type:type,info:info,__enum__:"mnsl.parser.MNSLNode",toString:$estr}; },$_._hx_name="Identifier",$_.__params__ = ["name","type","info"],$_)
	,IfStatement: ($_=function(condition,body,info) { return {_hx_index:6,condition:condition,body:body,info:info,__enum__:"mnsl.parser.MNSLNode",toString:$estr}; },$_._hx_name="IfStatement",$_.__params__ = ["condition","body","info"],$_)
	,ElseIfStatement: ($_=function(condition,body,info) { return {_hx_index:7,condition:condition,body:body,info:info,__enum__:"mnsl.parser.MNSLNode",toString:$estr}; },$_._hx_name="ElseIfStatement",$_.__params__ = ["condition","body","info"],$_)
	,ElseStatement: ($_=function(body,info) { return {_hx_index:8,body:body,info:info,__enum__:"mnsl.parser.MNSLNode",toString:$estr}; },$_._hx_name="ElseStatement",$_.__params__ = ["body","info"],$_)
	,BinaryOp: ($_=function(left,op,right,type,info) { return {_hx_index:9,left:left,op:op,right:right,type:type,info:info,__enum__:"mnsl.parser.MNSLNode",toString:$estr}; },$_._hx_name="BinaryOp",$_.__params__ = ["left","op","right","type","info"],$_)
	,UnaryOp: ($_=function(op,right,info) { return {_hx_index:10,op:op,right:right,info:info,__enum__:"mnsl.parser.MNSLNode",toString:$estr}; },$_._hx_name="UnaryOp",$_.__params__ = ["op","right","info"],$_)
	,WhileLoop: ($_=function(condition,body,info) { return {_hx_index:11,condition:condition,body:body,info:info,__enum__:"mnsl.parser.MNSLNode",toString:$estr}; },$_._hx_name="WhileLoop",$_.__params__ = ["condition","body","info"],$_)
	,ForLoop: ($_=function(init,condition,increment,body,info) { return {_hx_index:12,init:init,condition:condition,increment:increment,body:body,info:info,__enum__:"mnsl.parser.MNSLNode",toString:$estr}; },$_._hx_name="ForLoop",$_.__params__ = ["init","condition","increment","body","info"],$_)
	,Break: ($_=function(info) { return {_hx_index:13,info:info,__enum__:"mnsl.parser.MNSLNode",toString:$estr}; },$_._hx_name="Break",$_.__params__ = ["info"],$_)
	,Continue: ($_=function(info) { return {_hx_index:14,info:info,__enum__:"mnsl.parser.MNSLNode",toString:$estr}; },$_._hx_name="Continue",$_.__params__ = ["info"],$_)
	,SubExpression: ($_=function(node,info) { return {_hx_index:15,node:node,info:info,__enum__:"mnsl.parser.MNSLNode",toString:$estr}; },$_._hx_name="SubExpression",$_.__params__ = ["node","info"],$_)
	,Block: ($_=function(body,info) { return {_hx_index:16,body:body,info:info,__enum__:"mnsl.parser.MNSLNode",toString:$estr}; },$_._hx_name="Block",$_.__params__ = ["body","info"],$_)
	,StructAccess: ($_=function(on,field,type,info) { return {_hx_index:17,on:on,field:field,type:type,info:info,__enum__:"mnsl.parser.MNSLNode",toString:$estr}; },$_._hx_name="StructAccess",$_.__params__ = ["on","field","type","info"],$_)
	,ArrayAccess: ($_=function(on,index,info) { return {_hx_index:18,on:on,index:index,info:info,__enum__:"mnsl.parser.MNSLNode",toString:$estr}; },$_._hx_name="ArrayAccess",$_.__params__ = ["on","index","info"],$_)
	,TypeCast: ($_=function(on,from,to) { return {_hx_index:19,on:on,from:from,to:to,__enum__:"mnsl.parser.MNSLNode",toString:$estr}; },$_._hx_name="TypeCast",$_.__params__ = ["on","from","to"],$_)
	,VoidNode: ($_=function(info) { return {_hx_index:20,info:info,__enum__:"mnsl.parser.MNSLNode",toString:$estr}; },$_._hx_name="VoidNode",$_.__params__ = ["info"],$_)
	,TypeWrapper: ($_=function(type) { return {_hx_index:21,type:type,__enum__:"mnsl.parser.MNSLNode",toString:$estr}; },$_._hx_name="TypeWrapper",$_.__params__ = ["type"],$_)
	,VectorCreation: ($_=function(components,nodes,info) { return {_hx_index:22,components:components,nodes:nodes,info:info,__enum__:"mnsl.parser.MNSLNode",toString:$estr}; },$_._hx_name="VectorCreation",$_.__params__ = ["components","nodes","info"],$_)
	,VectorConversion: ($_=function(on,fromComponents,toComponents) { return {_hx_index:23,on:on,fromComponents:fromComponents,toComponents:toComponents,__enum__:"mnsl.parser.MNSLNode",toString:$estr}; },$_._hx_name="VectorConversion",$_.__params__ = ["on","fromComponents","toComponents"],$_)
	,IntegerLiteralNode: ($_=function(value,info) { return {_hx_index:24,value:value,info:info,__enum__:"mnsl.parser.MNSLNode",toString:$estr}; },$_._hx_name="IntegerLiteralNode",$_.__params__ = ["value","info"],$_)
	,FloatLiteralNode: ($_=function(value,info) { return {_hx_index:25,value:value,info:info,__enum__:"mnsl.parser.MNSLNode",toString:$estr}; },$_._hx_name="FloatLiteralNode",$_.__params__ = ["value","info"],$_)
	,StringLiteralNode: ($_=function(value,info) { return {_hx_index:26,value:value,info:info,__enum__:"mnsl.parser.MNSLNode",toString:$estr}; },$_._hx_name="StringLiteralNode",$_.__params__ = ["value","info"],$_)
	,BooleanLiteralNode: ($_=function(value,info) { return {_hx_index:27,value:value,info:info,__enum__:"mnsl.parser.MNSLNode",toString:$estr}; },$_._hx_name="BooleanLiteralNode",$_.__params__ = ["value","info"],$_)
};
mnsl_parser_MNSLNode.__constructs__ = [mnsl_parser_MNSLNode.FunctionDecl,mnsl_parser_MNSLNode.FunctionCall,mnsl_parser_MNSLNode.Return,mnsl_parser_MNSLNode.VariableDecl,mnsl_parser_MNSLNode.VariableAssign,mnsl_parser_MNSLNode.Identifier,mnsl_parser_MNSLNode.IfStatement,mnsl_parser_MNSLNode.ElseIfStatement,mnsl_parser_MNSLNode.ElseStatement,mnsl_parser_MNSLNode.BinaryOp,mnsl_parser_MNSLNode.UnaryOp,mnsl_parser_MNSLNode.WhileLoop,mnsl_parser_MNSLNode.ForLoop,mnsl_parser_MNSLNode.Break,mnsl_parser_MNSLNode.Continue,mnsl_parser_MNSLNode.SubExpression,mnsl_parser_MNSLNode.Block,mnsl_parser_MNSLNode.StructAccess,mnsl_parser_MNSLNode.ArrayAccess,mnsl_parser_MNSLNode.TypeCast,mnsl_parser_MNSLNode.VoidNode,mnsl_parser_MNSLNode.TypeWrapper,mnsl_parser_MNSLNode.VectorCreation,mnsl_parser_MNSLNode.VectorConversion,mnsl_parser_MNSLNode.IntegerLiteralNode,mnsl_parser_MNSLNode.FloatLiteralNode,mnsl_parser_MNSLNode.StringLiteralNode,mnsl_parser_MNSLNode.BooleanLiteralNode];
var mnsl_parser_MNSLNodeInfo = function(fromLine,fromColumn,toLine,toColumn) {
	this.fromLine = fromLine;
	this.fromColumn = fromColumn;
	this.toLine = toLine;
	this.toColumn = toColumn;
};
mnsl_parser_MNSLNodeInfo.__name__ = true;
mnsl_parser_MNSLNodeInfo.fromTokenInfo = function(tokenInfo) {
	return new mnsl_parser_MNSLNodeInfo(tokenInfo.line,tokenInfo.column,tokenInfo.line,tokenInfo.column + tokenInfo.length);
};
mnsl_parser_MNSLNodeInfo.fromTokenInfos = function(tokenInfos) {
	var first = new mnsl_tokenizer_MNSLTokenInfo(255,255,null,0);
	var tmp = tokenInfos[0];
	var last = tmp != null ? tmp : new mnsl_tokenizer_MNSLTokenInfo(0,0,null,0);
	var _g = 0;
	while(_g < tokenInfos.length) {
		var tokenInfo = tokenInfos[_g];
		++_g;
		if(tokenInfo == null) {
			continue;
		}
		if(tokenInfo.line < first.line || tokenInfo.line == first.line && tokenInfo.column < first.column) {
			first = tokenInfo;
		}
		if(tokenInfo.line > last.line || tokenInfo.line == last.line && tokenInfo.column + tokenInfo.length > last.column + last.length) {
			last = tokenInfo;
		}
	}
	return new mnsl_parser_MNSLNodeInfo(first.line,first.column,last.line,last.column + last.length);
};
mnsl_parser_MNSLNodeInfo.prototype = {
	toString: function() {
		return this.fromLine + ":" + this.fromColumn + " - " + this.toLine + ":" + this.toColumn;
	}
	,__class__: mnsl_parser_MNSLNodeInfo
};
var mnsl_parser_MNSLParser = function(context,tokens) {
	this.operators = ["Plus","Minus","Star","Slash","Percent","Equal","NotEqual","Greater","GreaterEqual","Less","LessEqual","And","Or","Not"];
	this.keywords = ["func","return","var","if","else","while","for","break","continue"];
	this.tokens = tokens;
	this.currentIndex = 0;
	this.ast = [];
	this.context = context;
	this.dataList = [];
};
mnsl_parser_MNSLParser.__name__ = true;
mnsl_parser_MNSLParser.prototype = {
	getDataList: function() {
		return this.dataList;
	}
	,run: function() {
		this._runInternal();
		return new mnsl_parser_MNSLParserResults(this.ast,this.dataList);
	}
	,_runInternal: function() {
		while(this.currentIndex < this.tokens.length) {
			var token = this.tokens[this.currentIndex];
			this.currentIndex++;
			switch(token._hx_index) {
			case 1:
				var _g = token.info;
				this.parseMeta(token);
				break;
			case 2:
				var value = token.value;
				var info = token.info;
				this.parseIdentifier(value,info);
				break;
			case 3:
				var value1 = token.value;
				var info1 = token.info;
				this.append(mnsl_parser_MNSLNode.IntegerLiteralNode(value1,mnsl_parser_MNSLNodeInfo.fromTokenInfo(info1)));
				break;
			case 4:
				var value2 = token.value;
				var info2 = token.info;
				this.append(mnsl_parser_MNSLNode.FloatLiteralNode(value2,mnsl_parser_MNSLNodeInfo.fromTokenInfo(info2)));
				break;
			case 5:
				var value3 = token.value;
				var info3 = token.info;
				this.append(mnsl_parser_MNSLNode.StringLiteralNode(value3,mnsl_parser_MNSLNodeInfo.fromTokenInfo(info3)));
				break;
			case 6:
				var _g1 = token.info;
				this.parseSubExpression(token);
				break;
			case 8:
				var _g2 = token.info;
				this.parseArrayAccess(token);
				break;
			case 13:
				var _g3 = token.info;
				this.parseStructAccess(token);
				break;
			case 16:
				var _g4 = token.info;
				continue;
			case 21:
				var _g5 = token.info;
				this.parseVarAssign(this.getCurrentTokenValue(),this.getTokenInfo(token));
				break;
			default:
				if(this.isOperator(token)) {
					var _g6 = this.peekCurrentToken(0);
					var tmp;
					if(_g6._hx_index == 21) {
						var _g7 = _g6.info;
						tmp = true;
					} else {
						tmp = false;
					}
					if(tmp) {
						this.getCurrentToken();
						this.parseOperatorAssignment(token);
						continue;
					}
					this.parseOperator(token);
					continue;
				}
				this.context.emitError(mnsl_MNSLError.ParserInvalidToken(token));
			}
		}
		return this.ast;
	}
	,parseStructAccess: function(token) {
		var accessOn = this.pop();
		if(accessOn == null) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedExpression(accessOn,null));
			return;
		}
		var accessName = this.getCurrentTokenValue();
		if(accessName == null) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(this.tokens[this.currentIndex],null));
			return;
		}
		this.append(mnsl_parser_MNSLNode.StructAccess(accessOn,accessName,new mnsl_analysis_MNSLType("Unknown"),mnsl_parser_MNSLNodeInfo.fromTokenInfos([this.getTokenInfo(token),this.getTokenInfo(this.tokens[this.currentIndex - 1])])));
	}
	,parseArrayAccess: function(token) {
		var accessOn = this.pop();
		if(accessOn == null) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedExpression(accessOn,null));
			return;
		}
		var accessBlock = this.getBlock(mnsl_tokenizer_MNSLToken.LeftBracket(null),mnsl_tokenizer_MNSLToken.RightBracket(null),1);
		var accessCtx = new mnsl_parser_MNSLParser(this.context,accessBlock);
		var access = accessCtx._runInternal();
		if(access.length == 0) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(accessBlock[0],null));
			return;
		}
		if(access.length > 1) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedExpression(access[1],null));
			return;
		}
		this.append(mnsl_parser_MNSLNode.ArrayAccess(accessOn,access[0],mnsl_parser_MNSLNodeInfo.fromTokenInfos([this.getTokenInfo(token),this.getTokenInfo(accessBlock[accessBlock.length - 1])])));
	}
	,parseMeta: function(token) {
		var name = this.getCurrentTokenValue();
		if(name == null) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(this.tokens[this.currentIndex],null));
			return;
		}
		if(this.peekCurrentTokenType(0) != "LeftParen") {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(this.tokens[this.currentIndex],null));
			return;
		}
		var block = this.getBlock(mnsl_tokenizer_MNSLToken.LeftParen(null),mnsl_tokenizer_MNSLToken.RightParen(null));
		switch(name) {
		case "define":
			this.parseDefineMeta(block);
			break;
		case "input":
			this.parseShaderDataMeta(block,mnsl_parser_MNSLShaderDataKind.Input);
			break;
		case "output":
			this.parseShaderDataMeta(block,mnsl_parser_MNSLShaderDataKind.Output);
			break;
		case "uniform":
			this.parseShaderDataMeta(block,mnsl_parser_MNSLShaderDataKind.Uniform);
			break;
		}
	}
	,parseShaderDataMeta: function(block,kind) {
		var nameToken = block[0];
		var name = this.getTokenValue(nameToken);
		if(name == null) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(nameToken,null));
			return;
		}
		var colonToken = block[1];
		var tmp;
		if(colonToken != null) {
			var tmp1;
			if(colonToken._hx_index == 23) {
				var _g = colonToken.info;
				tmp1 = true;
			} else {
				tmp1 = false;
			}
			tmp = !tmp1;
		} else {
			tmp = true;
		}
		if(tmp) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(colonToken,null));
			return;
		}
		var typeToken = block[2];
		var type = this.getTokenValue(typeToken);
		if(type == null) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(typeToken,null));
			return;
		}
		var bracketOpenToken = block[3];
		var arraySize = block[4];
		var arraySizeInt = -1;
		var bracketCloseToken = block[5];
		if(bracketOpenToken != null) {
			var tmp;
			if(bracketOpenToken._hx_index == 8) {
				var _g = bracketOpenToken.info;
				tmp = true;
			} else {
				tmp = false;
			}
			if(!tmp) {
				this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(bracketOpenToken,null));
				return;
			}
			if(arraySize == null) {
				this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(arraySize,null));
				return;
			}
			var tmp;
			if(bracketCloseToken != null) {
				var tmp1;
				if(bracketCloseToken._hx_index == 9) {
					var _g = bracketCloseToken.info;
					tmp1 = true;
				} else {
					tmp1 = false;
				}
				tmp = !tmp1;
			} else {
				tmp = true;
			}
			if(tmp) {
				this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(bracketCloseToken,null));
				return;
			}
			var tmp;
			if(arraySize._hx_index == 3) {
				var _g = arraySize.value;
				var _g = arraySize.info;
				tmp = true;
			} else {
				tmp = false;
			}
			if(!tmp) {
				var tmp;
				if(arraySize._hx_index == 2) {
					var _g = arraySize.value;
					var _g = arraySize.info;
					tmp = true;
				} else {
					tmp = false;
				}
				if(!tmp) {
					this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(arraySize,null));
					return;
				}
				var defineValues = this.context.getDefine(this.getTokenValue(arraySize));
				if(defineValues == null) {
					this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(arraySize,null));
					return;
				}
				var defineValue = defineValues[0];
				if(defineValue == null) {
					this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(arraySize,null));
					return;
				}
				var tmp;
				if(defineValue._hx_index == 3) {
					var _g = defineValue.value;
					var _g = defineValue.info;
					tmp = true;
				} else {
					tmp = false;
				}
				if(!tmp) {
					this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(arraySize,null));
					return;
				}
				arraySizeInt = Std.parseInt(this.getTokenValue(defineValue));
			} else {
				arraySizeInt = Std.parseInt(this.getTokenValue(arraySize));
			}
		}
		var shData = new mnsl_parser_MNSLShaderData(kind,arraySizeInt == -1 ? new mnsl_analysis_MNSLType(type) : mnsl_analysis_MNSLType.Array(type,arraySizeInt),name,arraySizeInt);
		this.dataList.push(shData);
	}
	,parseDefineMeta: function(block) {
		var nameToken = block[0];
		var name = this.getTokenValue(nameToken);
		if(name == null) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(nameToken,null));
			return;
		}
		var commaToken = block[1];
		var tmp;
		if(commaToken != null) {
			var tmp1;
			if(commaToken._hx_index == 12) {
				var _g = commaToken.info;
				tmp1 = true;
			} else {
				tmp1 = false;
			}
			tmp = !tmp1;
		} else {
			tmp = true;
		}
		if(tmp) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(commaToken,null));
			return;
		}
		var valueTokens = block.slice(2);
		if(valueTokens.length == 0) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(valueTokens[2],null));
			return;
		}
		this.context.setDefine(name,valueTokens);
	}
	,parseSubExpression: function(token) {
		var block = this.getBlock(mnsl_tokenizer_MNSLToken.LeftParen(null),mnsl_tokenizer_MNSLToken.RightParen(null),1);
		var parts = this.splitBlock(block,mnsl_tokenizer_MNSLToken.Comma(null));
		var nodes = [];
		var _g = 0;
		while(_g < parts.length) {
			var part = parts[_g];
			++_g;
			var parser = new mnsl_parser_MNSLParser(this.context,part);
			var parsed = parser._runInternal();
			if(parsed.length == 0) {
				this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(part[0],null));
				return;
			}
			if(parsed.length > 1) {
				this.context.emitError(mnsl_MNSLError.ParserUnexpectedExpression(parsed[1],null));
				return;
			}
			nodes.push(parsed[0]);
		}
		if(nodes.length > 1) {
			this.append(mnsl_parser_MNSLNode.VectorCreation(nodes.length,nodes,mnsl_parser_MNSLNodeInfo.fromTokenInfos([this.getTokenInfo(token),this.getTokenInfo(block[block.length - 1])])));
		} else {
			this.append(mnsl_parser_MNSLNode.SubExpression(nodes[0],mnsl_parser_MNSLNodeInfo.fromTokenInfos([this.getTokenInfo(token),this.getTokenInfo(block[block.length - 1])])));
		}
	}
	,parseIdentifier: function(value,info) {
		if(this.context.getDefine(value) != null) {
			var parseCtx = new mnsl_parser_MNSLParser(this.context,this.context.getDefine(value));
			var parsed = parseCtx._runInternal();
			if(parsed.length == 0) {
				this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(this.context.getDefine(value)[0],info));
				return;
			}
			if(parsed.length > 1) {
				this.context.emitError(mnsl_MNSLError.ParserUnexpectedExpression(parsed[1],null));
				return;
			}
			this.append(parsed[0]);
			return;
		}
		if(this.keywords.indexOf(value) != -1) {
			this.parseKeyword(value,info);
			return;
		}
		var nextToken = this.peekCurrentTokenType(0);
		if(nextToken == "LeftParen") {
			this.parseFunctionCall(value,info);
			return;
		}
		if(value == "true") {
			this.append(mnsl_parser_MNSLNode.BooleanLiteralNode(true,mnsl_parser_MNSLNodeInfo.fromTokenInfo(info)));
			return;
		}
		if(value == "false") {
			this.append(mnsl_parser_MNSLNode.BooleanLiteralNode(false,mnsl_parser_MNSLNodeInfo.fromTokenInfo(info)));
			return;
		}
		if(this.keywords.indexOf(value) != -1) {
			this.context.emitError(mnsl_MNSLError.ParserInvalidKeyword(value,info));
			return;
		}
		this.append(mnsl_parser_MNSLNode.Identifier(value,new mnsl_analysis_MNSLType("Unknown"),mnsl_parser_MNSLNodeInfo.fromTokenInfo(info)));
	}
	,parseKeyword: function(value,info) {
		switch(value) {
		case "break":
			this.append(mnsl_parser_MNSLNode.Break(mnsl_parser_MNSLNodeInfo.fromTokenInfo(info)));
			break;
		case "continue":
			this.append(mnsl_parser_MNSLNode.Continue(mnsl_parser_MNSLNodeInfo.fromTokenInfo(info)));
			break;
		case "else":
			if(this.peekCurrentTokenType(0) == "Identifier" && this.peekCurrentTokenValue(0) == "if") {
				this.currentIndex++;
				this.parseElseIfStmt(value,info);
			} else {
				this.parseElseStmt(value,info);
			}
			break;
		case "for":
			this.parseForStmt(value,info);
			break;
		case "func":
			this.parseFunctionDecl(value,info);
			break;
		case "if":
			this.parseIfStmt(value,info);
			break;
		case "return":
			this.parseReturnStmt(value,info);
			break;
		case "var":
			this.parseVarDecl(value,info);
			break;
		case "while":
			this.parseWhileStmt(value,info);
			break;
		default:
			this.context.emitError(mnsl_MNSLError.ParserInvalidKeyword(value,info));
		}
	}
	,parseWhileStmt: function(value,info) {
		var conditionBlock = this.getBlock(mnsl_tokenizer_MNSLToken.LeftParen(null),mnsl_tokenizer_MNSLToken.RightParen(null));
		var conditionTokens = this.splitBlock(conditionBlock,mnsl_tokenizer_MNSLToken.Comma(null));
		var conditions = [];
		var _g = 0;
		while(_g < conditionTokens.length) {
			var conditionTokens1 = conditionTokens[_g];
			++_g;
			var c = new mnsl_parser_MNSLParser(this.context,conditionTokens1);
			var cond = c._runInternal();
			if(cond.length == 0) {
				this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(conditionTokens1[0],info));
				continue;
			}
			if(cond.length > 1) {
				this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(conditionTokens1[1],info));
				continue;
			}
			conditions.push(cond[0]);
		}
		if(conditions.length == 0) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(conditionBlock[0],info));
			return;
		}
		if(conditions.length > 1) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(conditionBlock[1],info));
			return;
		}
		var bodyBlock = this.getBlock(mnsl_tokenizer_MNSLToken.LeftBrace(null),mnsl_tokenizer_MNSLToken.RightBrace(null));
		var body = new mnsl_parser_MNSLParser(this.context,bodyBlock)._runInternal();
		this.append(mnsl_parser_MNSLNode.WhileLoop(conditions[0],body,mnsl_parser_MNSLNodeInfo.fromTokenInfos([info,this.getTokenInfo(conditionBlock[conditionBlock.length - 1])])));
	}
	,parseForStmt: function(value,info) {
		var forParamBlock = this.getBlock(mnsl_tokenizer_MNSLToken.LeftParen(null),mnsl_tokenizer_MNSLToken.RightParen(null));
		var forParamTokens = this.splitBlock(forParamBlock,mnsl_tokenizer_MNSLToken.Semicolon(null));
		if(forParamTokens.length != 3) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(forParamBlock[0],info));
			return;
		}
		var initBlock = new mnsl_parser_MNSLParser(this.context,forParamTokens[0])._runInternal();
		var conditionBlock = new mnsl_parser_MNSLParser(this.context,forParamTokens[1])._runInternal();
		var incrementBlock = new mnsl_parser_MNSLParser(this.context,forParamTokens[2])._runInternal();
		if(initBlock.length == 0) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(forParamTokens[0][0],info));
			return;
		}
		if(conditionBlock.length == 0) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(forParamTokens[1][0],info));
			return;
		}
		if(incrementBlock.length == 0) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(forParamTokens[2][0],info));
			return;
		}
		if(initBlock.length > 1) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(forParamTokens[0][1],info));
			return;
		}
		if(conditionBlock.length > 1) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(forParamTokens[1][1],info));
			return;
		}
		if(incrementBlock.length > 1) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(forParamTokens[2][1],info));
			return;
		}
		var bodyBlock = this.getBlock(mnsl_tokenizer_MNSLToken.LeftBrace(null),mnsl_tokenizer_MNSLToken.RightBrace(null));
		var body = new mnsl_parser_MNSLParser(this.context,bodyBlock)._runInternal();
		this.append(mnsl_parser_MNSLNode.ForLoop(initBlock[0],conditionBlock[0],incrementBlock[0],body,mnsl_parser_MNSLNodeInfo.fromTokenInfos([info,this.getTokenInfo(forParamBlock[forParamBlock.length - 1])])));
	}
	,parseIfStmt: function(value,info) {
		var conditionBlock = this.getBlock(mnsl_tokenizer_MNSLToken.LeftParen(null),mnsl_tokenizer_MNSLToken.RightParen(null));
		var conditionTokens = this.splitBlock(conditionBlock,mnsl_tokenizer_MNSLToken.Comma(null));
		var conditions = [];
		var _g = 0;
		while(_g < conditionTokens.length) {
			var conditionTokens1 = conditionTokens[_g];
			++_g;
			var c = new mnsl_parser_MNSLParser(this.context,conditionTokens1);
			var cond = c._runInternal();
			if(cond.length == 0) {
				this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(conditionTokens1[0],info));
				continue;
			}
			if(cond.length > 1) {
				this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(conditionTokens1[1],info));
				continue;
			}
			conditions.push(cond[0]);
		}
		if(conditions.length == 0) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(conditionBlock[0],info));
			return;
		}
		if(conditions.length > 1) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(conditionBlock[1],info));
			return;
		}
		var bodyBlock = this.getBlock(mnsl_tokenizer_MNSLToken.LeftBrace(null),mnsl_tokenizer_MNSLToken.RightBrace(null));
		var body = new mnsl_parser_MNSLParser(this.context,bodyBlock)._runInternal();
		this.append(mnsl_parser_MNSLNode.IfStatement(conditions[0],body,mnsl_parser_MNSLNodeInfo.fromTokenInfos([info,this.getTokenInfo(conditionBlock[conditionBlock.length - 1])])));
	}
	,parseElseStmt: function(value,info) {
		var last = this.peekLast();
		var tmp;
		if(last != null) {
			var tmp1;
			if(last._hx_index == 6) {
				var _g = last.condition;
				var _g = last.body;
				var _g = last.info;
				tmp1 = true;
			} else {
				tmp1 = false;
			}
			if(!tmp1) {
				var tmp1;
				if(last._hx_index == 7) {
					var _g = last.condition;
					var _g = last.body;
					var _g = last.info;
					tmp1 = true;
				} else {
					tmp1 = false;
				}
				tmp = !tmp1;
			} else {
				tmp = false;
			}
		} else {
			tmp = true;
		}
		if(tmp) {
			this.context.emitError(mnsl_MNSLError.ParserConditionalWithoutIf(info));
			return;
		}
		var bodyBlock = this.getBlock(mnsl_tokenizer_MNSLToken.LeftBrace(null),mnsl_tokenizer_MNSLToken.RightBrace(null));
		var body = new mnsl_parser_MNSLParser(this.context,bodyBlock)._runInternal();
		this.append(mnsl_parser_MNSLNode.ElseStatement(body,mnsl_parser_MNSLNodeInfo.fromTokenInfos([info,this.getTokenInfo(bodyBlock[bodyBlock.length - 1])])));
	}
	,parseElseIfStmt: function(value,info) {
		var last = this.peekLast();
		var tmp;
		if(last != null) {
			var tmp1;
			var tmp2;
			if(last._hx_index == 6) {
				var _g = last.condition;
				var _g = last.body;
				var _g = last.info;
				tmp2 = true;
			} else {
				tmp2 = false;
			}
			if(!tmp2) {
				if(last._hx_index == 7) {
					var _g = last.condition;
					var _g = last.body;
					var _g = last.info;
					tmp1 = true;
				} else {
					tmp1 = false;
				}
			} else {
				tmp1 = true;
			}
			tmp = !tmp1;
		} else {
			tmp = true;
		}
		if(tmp) {
			this.context.emitError(mnsl_MNSLError.ParserConditionalWithoutIf(info));
			return;
		}
		var conditionBlock = this.getBlock(mnsl_tokenizer_MNSLToken.LeftParen(null),mnsl_tokenizer_MNSLToken.RightParen(null));
		var conditionTokens = this.splitBlock(conditionBlock,mnsl_tokenizer_MNSLToken.Comma(null));
		var conditions = [];
		var _g = 0;
		while(_g < conditionTokens.length) {
			var conditionTokens1 = conditionTokens[_g];
			++_g;
			var c = new mnsl_parser_MNSLParser(this.context,conditionTokens1);
			var cond = c._runInternal();
			if(cond.length == 0) {
				this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(conditionTokens1[0],info));
				continue;
			}
			if(cond.length > 1) {
				this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(conditionTokens1[1],info));
				continue;
			}
			conditions.push(cond[0]);
		}
		if(conditions.length == 0) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(conditionBlock[0],info));
			return;
		}
		if(conditions.length > 1) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(conditionBlock[1],info));
			return;
		}
		var bodyBlock = this.getBlock(mnsl_tokenizer_MNSLToken.LeftBrace(null),mnsl_tokenizer_MNSLToken.RightBrace(null));
		var body = new mnsl_parser_MNSLParser(this.context,bodyBlock)._runInternal();
		this.append(mnsl_parser_MNSLNode.ElseIfStatement(conditions[0],body,mnsl_parser_MNSLNodeInfo.fromTokenInfos([info,this.getTokenInfo(conditionBlock[conditionBlock.length - 1])])));
	}
	,parseVarDecl: function(value,info) {
		var name = this.getCurrentTokenValue();
		if(name == null) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(this.tokens[this.currentIndex],info));
			return;
		}
		var type = new mnsl_analysis_MNSLType("Unknown");
		if(this.peekCurrentTokenType(0) == "Colon") {
			this.currentIndex++;
			var typeStr = this.getCurrentTokenValue();
			if(typeStr == null) {
				this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(this.tokens[this.currentIndex],info));
				return;
			}
			type.setTypeStrUnsafe(typeStr);
		}
		var nextToken = this.peekCurrentTokenType(0);
		if(nextToken == "Assign") {
			this.currentIndex++;
			var valueBlock = this.getBlock(mnsl_tokenizer_MNSLToken.None,mnsl_tokenizer_MNSLToken.Semicolon(null),1);
			var c = new mnsl_parser_MNSLParser(this.context,valueBlock);
			var value = c._runInternal();
			if(value.length == 0) {
				this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(valueBlock[0],info));
				return;
			}
			if(value.length > 1) {
				this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(valueBlock[1],info));
				return;
			}
			if(this.keywords.indexOf(name) != -1) {
				this.context.emitError(mnsl_MNSLError.ParserInvalidKeyword(name,info));
				return;
			}
			this.append(mnsl_parser_MNSLNode.VariableDecl(name,type,value[0],mnsl_parser_MNSLNodeInfo.fromTokenInfos([info,this.getTokenInfo(valueBlock[valueBlock.length - 1])])));
			return;
		}
		this.append(mnsl_parser_MNSLNode.VariableDecl(name,type,null,mnsl_parser_MNSLNodeInfo.fromTokenInfos([info,this.getTokenInfo(this.tokens[this.currentIndex - 1])])));
	}
	,parseVarAssign: function(value,info) {
		var name = this.pop();
		this.currentIndex--;
		var assignBlock = this.getBlock(mnsl_tokenizer_MNSLToken.None,mnsl_tokenizer_MNSLToken.Semicolon(null),1);
		var c = new mnsl_parser_MNSLParser(this.context,assignBlock);
		var value = c._runInternal();
		if(value.length == 0) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(assignBlock[0],info));
			return;
		}
		if(value.length > 1) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(assignBlock[1],info));
			return;
		}
		this.append(mnsl_parser_MNSLNode.VariableAssign(name,value[0],mnsl_parser_MNSLNodeInfo.fromTokenInfos([info,this.getTokenInfo(assignBlock[assignBlock.length - 1])])));
	}
	,parseOperatorAssignment: function(token) {
		var oper = token;
		var left = this.pop();
		if(left == null) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedExpression(left,null));
			return;
		}
		var rightTokens = [];
		while(true) {
			var tmp;
			if(this.currentIndex < this.tokens.length) {
				var _g = this.tokens[this.currentIndex];
				var tmp1;
				if(_g._hx_index == 16) {
					var _g1 = _g.info;
					tmp1 = true;
				} else {
					tmp1 = false;
				}
				tmp = !tmp1;
			} else {
				tmp = false;
			}
			if(!tmp) {
				break;
			}
			rightTokens.push(this.tokens[this.currentIndex]);
			this.currentIndex++;
		}
		if(rightTokens.length == 0) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(this.tokens[this.currentIndex],null));
			return;
		}
		var right = new mnsl_parser_MNSLParser(this.context,rightTokens)._runInternal();
		if(right.length == 0) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(rightTokens[0],null));
			return;
		}
		if(right.length > 1) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedExpression(right[1],null));
			return;
		}
		this.append(mnsl_parser_MNSLNode.VariableAssign(left,mnsl_parser_MNSLNode.BinaryOp(left,oper,right[0],new mnsl_analysis_MNSLType("Unknown"),mnsl_parser_MNSLNodeInfo.fromTokenInfos([this.getTokenInfo(oper),this.getTokenInfo(rightTokens[rightTokens.length - 1])])),mnsl_parser_MNSLNodeInfo.fromTokenInfos([this.getTokenInfo(oper),this.getTokenInfo(rightTokens[rightTokens.length - 1])])));
	}
	,parseReturnStmt: function(value,info) {
		if(this.peekCurrentTokenType(0) == "Semicolon") {
			this.append(mnsl_parser_MNSLNode.Return(mnsl_parser_MNSLNode.VoidNode(mnsl_parser_MNSLNodeInfo.fromTokenInfo(info)),new mnsl_analysis_MNSLType("Unknown"),mnsl_parser_MNSLNodeInfo.fromTokenInfos([info,this.getTokenInfo(this.tokens[this.currentIndex - 1])])));
			return;
		}
		var returnBlock = this.getBlock(mnsl_tokenizer_MNSLToken.None,mnsl_tokenizer_MNSLToken.Semicolon(null),1);
		var c = new mnsl_parser_MNSLParser(this.context,returnBlock);
		var ret = c._runInternal();
		if(ret.length == 0) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(returnBlock[0],info));
			return;
		}
		if(ret.length > 1) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(returnBlock[returnBlock.length - 1],info));
			return;
		}
		this.append(mnsl_parser_MNSLNode.Return(ret[0],new mnsl_analysis_MNSLType("Unknown"),mnsl_parser_MNSLNodeInfo.fromTokenInfos([info,this.getTokenInfo(returnBlock[returnBlock.length - 1])])));
	}
	,parseFunctionCall: function(value,info) {
		var name = value;
		var argsBlock = this.getBlock(mnsl_tokenizer_MNSLToken.LeftParen(null),mnsl_tokenizer_MNSLToken.RightParen(null));
		var argsTokens = this.splitBlock(argsBlock,mnsl_tokenizer_MNSLToken.Comma(null));
		var args = [];
		var _g = 0;
		while(_g < argsTokens.length) {
			var argTokens = argsTokens[_g];
			++_g;
			var c = new mnsl_parser_MNSLParser(this.context,argTokens);
			var arg = c._runInternal();
			if(arg.length == 0) {
				this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(argTokens[0],info));
				continue;
			}
			if(arg.length > 1) {
				this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(argTokens[1],info));
				continue;
			}
			args.push(arg[0]);
		}
		if(name == "vec2" || name == "vec3" || name == "vec4") {
			var comp = Std.parseInt(HxOverrides.substr(name,3,null));
			var info1 = mnsl_parser_MNSLNodeInfo.fromTokenInfos([this.getTokenInfo(argsBlock[0]),this.getTokenInfo(argsBlock[argsBlock.length - 1])]);
			this.append(mnsl_parser_MNSLNode.VectorCreation(comp,args,info1));
			return;
		}
		this.append(mnsl_parser_MNSLNode.FunctionCall(name,args,new mnsl_analysis_MNSLType("Unknown"),mnsl_parser_MNSLNodeInfo.fromTokenInfos([info,this.getTokenInfo(argsBlock[argsBlock.length - 1])])));
	}
	,parseFunctionDecl: function(value,info) {
		var name = this.getCurrentTokenValue();
		if(name == null) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(this.tokens[this.currentIndex],info));
			return;
		}
		var returnType = new mnsl_analysis_MNSLType("Unknown");
		var params = [];
		var paramBlock = this.getBlock(mnsl_tokenizer_MNSLToken.LeftParen(null),mnsl_tokenizer_MNSLToken.RightParen(null));
		var paramsTokens = this.splitBlock(paramBlock,mnsl_tokenizer_MNSLToken.Comma(null));
		var _g = 0;
		while(_g < paramsTokens.length) {
			var paramTokens = paramsTokens[_g];
			++_g;
			var c = new mnsl_parser_MNSLParser(this.context,paramTokens);
			var name1 = c.getCurrentTokenValue();
			if(name1 == null) {
				this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(paramTokens[0],info));
				continue;
			}
			var paramType = new mnsl_analysis_MNSLType("Unknown");
			params.push(new mnsl_analysis_MNSLFuncArg(name1,paramType));
			var t = c.getCurrentTokenType(1);
			if(t == null) {
				continue;
			}
			if(t != "Colon") {
				this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(paramTokens[0],info));
				continue;
			}
			var type = c.getCurrentTokenValue();
			if(type == null) {
				this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(paramTokens[0],info));
				continue;
			}
			paramType.setTypeStrUnsafe(type);
		}
		if(this.peekCurrentTokenType(0) == "Colon") {
			this.currentIndex++;
			var type = this.getCurrentTokenValue();
			if(type == null) {
				this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(this.tokens[this.currentIndex],info));
				return;
			}
			returnType.setTypeStrUnsafe(type);
		}
		var bodyBlock = this.getBlock(mnsl_tokenizer_MNSLToken.LeftBrace(null),mnsl_tokenizer_MNSLToken.RightBrace(null));
		var body = new mnsl_parser_MNSLParser(this.context,bodyBlock)._runInternal();
		this.append(mnsl_parser_MNSLNode.FunctionDecl(name,returnType,params,body,mnsl_parser_MNSLNodeInfo.fromTokenInfos([info,this.getTokenInfo(bodyBlock[bodyBlock.length - 1])])));
	}
	,parseOperator: function(token) {
		var precedence = this.getPrecedence(token);
		var left = this.pop();
		var rightTokens = [];
		var subExprDepth = 0;
		while(this.currentIndex < this.tokens.length) {
			var _g = this.tokens[this.currentIndex];
			var tmp;
			if(_g._hx_index == 6) {
				var _g1 = _g.info;
				tmp = true;
			} else {
				tmp = false;
			}
			if(tmp) {
				++subExprDepth;
			}
			if(this.isOperator(this.tokens[this.currentIndex]) && this.getPrecedence(this.tokens[this.currentIndex]) < precedence + 1 && subExprDepth == 0 && rightTokens.length > 0) {
				break;
			}
			var _g2 = this.tokens[this.currentIndex];
			var tmp1;
			if(_g2._hx_index == 7) {
				var _g3 = _g2.info;
				tmp1 = true;
			} else {
				tmp1 = false;
			}
			if(tmp1) {
				--subExprDepth;
			}
			rightTokens.push(this.tokens[this.currentIndex]);
			this.currentIndex++;
		}
		var right = new mnsl_parser_MNSLParser(this.context,rightTokens)._runInternal();
		if(right.length == 0) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(this.tokens[this.currentIndex],null));
			return;
		}
		if(right.length > 1) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedExpression(right[1],null));
			return;
		}
		if(left == null) {
			this.append(mnsl_parser_MNSLNode.UnaryOp(token,right[0],mnsl_parser_MNSLNodeInfo.fromTokenInfos([this.getTokenInfo(rightTokens[0]),this.getTokenInfo(rightTokens[rightTokens.length - 1])])));
			return;
		}
		this.append(mnsl_parser_MNSLNode.BinaryOp(left,token,right[0],new mnsl_analysis_MNSLType("Unknown"),mnsl_parser_MNSLNodeInfo.fromTokenInfos([this.getTokenInfo(rightTokens[0]),this.getTokenInfo(rightTokens[rightTokens.length - 1])])));
	}
	,append: function(node) {
		this.ast.push(node);
	}
	,pop: function() {
		if(this.ast.length == 0) {
			return null;
		}
		return this.ast.pop();
	}
	,peekLast: function() {
		if(this.ast.length == 0) {
			return null;
		}
		return this.ast[this.ast.length - 1];
	}
	,getBlock: function(start,end,startDepth,inc) {
		if(inc == null) {
			inc = 1;
		}
		if(startDepth == null) {
			startDepth = 0;
		}
		var block = [];
		var depth = startDepth;
		var token;
		var startTokenType = $hxEnums[start.__enum__].__constructs__[start._hx_index]._hx_name;
		var endTokenType = $hxEnums[end.__enum__].__constructs__[end._hx_index]._hx_name;
		while(this.currentIndex < this.tokens.length) {
			token = this.tokens[this.currentIndex];
			var tokenType = $hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name;
			if(tokenType == startTokenType) {
				++depth;
			} else if(tokenType == endTokenType) {
				--depth;
			}
			if(depth == 0) {
				break;
			}
			block.push(token);
			this.currentIndex++;
		}
		var tmp;
		if(block[0] != null && startDepth == 0) {
			var e = block[0];
			tmp = $hxEnums[e.__enum__].__constructs__[e._hx_index]._hx_name != startTokenType;
		} else {
			tmp = false;
		}
		if(tmp) {
			this.context.emitError(mnsl_MNSLError.ParserUnexpectedToken(block[0],null));
			return [];
		}
		this.currentIndex += inc;
		if(startDepth == 0) {
			return block.slice(1,block.length);
		} else {
			return block;
		}
	}
	,splitBlock: function(block,sep) {
		var blocks = [];
		var currentBlock = [];
		var sepType = $hxEnums[sep.__enum__].__constructs__[sep._hx_index]._hx_name;
		var depth = 0;
		var _g = 0;
		while(_g < block.length) {
			var token = block[_g];
			++_g;
			var tokenName = $hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name;
			if(tokenName == "LeftParen") {
				++depth;
			}
			if(tokenName == "RightParen") {
				--depth;
			}
			if(tokenName == sepType && depth == 0) {
				blocks.push(currentBlock);
				currentBlock = [];
			} else {
				currentBlock.push(token);
			}
		}
		if(currentBlock.length > 0) {
			blocks.push(currentBlock);
		}
		return blocks;
	}
	,getTokenValue: function(token) {
		switch(token._hx_index) {
		case 2:
			var _g = token.info;
			var value = token.value;
			return value;
		case 3:
			var _g = token.info;
			var value = token.value;
			return value;
		case 4:
			var _g = token.info;
			var value = token.value;
			return value;
		case 5:
			var _g = token.info;
			var value = token.value;
			return value;
		default:
			return null;
		}
	}
	,getTokenInfo: function(token) {
		if(token == null) {
			return null;
		}
		var params = Type.enumParameters(token);
		if(params.length == 0) {
			return null;
		}
		var _g = 0;
		while(_g < params.length) {
			var param = params[_g];
			++_g;
			if(((param) instanceof mnsl_tokenizer_MNSLTokenInfo)) {
				return param;
			}
		}
		return null;
	}
	,getCurrentTokenValue: function(inc) {
		if(inc == null) {
			inc = 1;
		}
		var t = this.tokens[this.currentIndex];
		if(t == null) {
			return null;
		}
		this.currentIndex += inc;
		return this.getTokenValue(t);
	}
	,getCurrentToken: function(inc) {
		if(inc == null) {
			inc = 1;
		}
		var t = this.tokens[this.currentIndex];
		this.currentIndex += inc;
		return t;
	}
	,getCurrentTokenType: function(inc) {
		var t = this.tokens[this.currentIndex];
		if(t == null) {
			return null;
		}
		this.currentIndex += inc;
		return $hxEnums[t.__enum__].__constructs__[t._hx_index]._hx_name;
	}
	,peekCurrentToken: function(inc) {
		var t = this.tokens[this.currentIndex + inc];
		if(t == null) {
			return null;
		}
		return t;
	}
	,peekCurrentTokenType: function(inc) {
		var t = this.tokens[this.currentIndex + inc];
		if(t == null) {
			return null;
		}
		return $hxEnums[t.__enum__].__constructs__[t._hx_index]._hx_name;
	}
	,peekCurrentTokenValue: function(inc) {
		var t = this.tokens[this.currentIndex + inc];
		if(t == null) {
			return null;
		}
		return this.getTokenValue(t);
	}
	,getPrecedence: function(op) {
		switch(op._hx_index) {
		case 14:
			var _g = op.info;
			return 5;
		case 15:
			var _g = op.info;
			return 5;
		case 17:
			var _g = op.info;
			return 6;
		case 18:
			var _g = op.info;
			return 6;
		case 19:
			var _g = op.info;
			return 6;
		case 22:
			var _g = op.info;
			return 3;
		case 25:
			var _g = op.info;
			return 2;
		case 26:
			var _g = op.info;
			return 1;
		case 27:
			var _g = op.info;
			return 4;
		case 28:
			var _g = op.info;
			return 4;
		case 29:
			var _g = op.info;
			return 4;
		case 30:
			var _g = op.info;
			return 4;
		case 31:
			var _g = op.info;
			return 3;
		case 32:
			var _g = op.info;
			return 7;
		default:
			throw haxe_Exception.thrown("Unknown operation: " + Std.string(op));
		}
	}
	,isOperator: function(token) {
		var name = $hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name;
		return this.operators.indexOf(name) != -1;
	}
	,__class__: mnsl_parser_MNSLParser
};
var mnsl_parser_MNSLParserResults = function(ast,dataList) {
	this.ast = ast;
	this.dataList = dataList;
};
mnsl_parser_MNSLParserResults.__name__ = true;
mnsl_parser_MNSLParserResults.prototype = {
	__class__: mnsl_parser_MNSLParserResults
};
var mnsl_parser_MNSLShaderData = function(kind,type,name,arraySize) {
	this.arraySize = -1;
	this.kind = kind;
	this.type = type;
	this.name = name;
	if(arraySize != null) {
		this.arraySize = arraySize;
	}
};
mnsl_parser_MNSLShaderData.__name__ = true;
mnsl_parser_MNSLShaderData.prototype = {
	__class__: mnsl_parser_MNSLShaderData
};
var mnsl_parser_MNSLShaderDataKind = $hxEnums["mnsl.parser.MNSLShaderDataKind"] = { __ename__:true,__constructs__:null
	,Input: {_hx_name:"Input",_hx_index:0,__enum__:"mnsl.parser.MNSLShaderDataKind",toString:$estr}
	,Output: {_hx_name:"Output",_hx_index:1,__enum__:"mnsl.parser.MNSLShaderDataKind",toString:$estr}
	,Uniform: {_hx_name:"Uniform",_hx_index:2,__enum__:"mnsl.parser.MNSLShaderDataKind",toString:$estr}
};
mnsl_parser_MNSLShaderDataKind.__constructs__ = [mnsl_parser_MNSLShaderDataKind.Input,mnsl_parser_MNSLShaderDataKind.Output,mnsl_parser_MNSLShaderDataKind.Uniform];
var mnsl_spirv_MNSLSPIRVConfig = function(shaderType) {
	this.shaderType = shaderType;
};
mnsl_spirv_MNSLSPIRVConfig.__name__ = true;
mnsl_spirv_MNSLSPIRVConfig.prototype = {
	__class__: mnsl_spirv_MNSLSPIRVConfig
};
var mnsl_spirv_MNSLSPIRVPrinter = function(context,config) {
	mnsl_MNSLPrinter.call(this,context);
	this._glslExtId = -1;
	this._componentList = ["x","y","z","w"];
	this._glslFuncMap = [{ name : "texture", mapping : -1},{ name : "dot", mapping : -1},{ name : "mod", mapping : -1},{ name : "sin", mapping : 13},{ name : "cos", mapping : 14},{ name : "tan", mapping : 15},{ name : "normalize", mapping : 69},{ name : "cross", mapping : 68},{ name : "length", mapping : 66},{ name : "reflect", mapping : 71},{ name : "refract", mapping : 72},{ name : "pow", mapping : 26},{ name : "exp", mapping : 27},{ name : "log", mapping : 28},{ name : "sqrt", mapping : 31},{ name : "abs", mapping : 4},{ name : "clamp", mapping : 43},{ name : "mix", mapping : 46},{ name : "step", mapping : 48},{ name : "smoothstep", mapping : 49},{ name : "max", mapping : 40},{ name : "min", mapping : 37},{ name : "atan", mapping : 25},{ name : "acos", mapping : 17},{ name : "asin", mapping : 16},{ name : "fract", mapping : 10},{ name : "floor", mapping : 8}];
	this._config = config;
	this._bin = new haxe_io_BytesOutput();
	this._types = new haxe_ds_ObjectMap();
	this._functions = new haxe_ds_StringMap();
	this._constants = new haxe_ds_StringMap();
	this._instructions = [];
	this._debugLabels = new haxe_ds_IntMap();
	this._functionTypes = new haxe_ds_StringMap();
	this._ptrTypes = new haxe_ds_StringMap();
	this._ptrInit = [];
	this._typeInit = [];
	this._constInit = [];
	this._decorations = [];
	this._idCount = 1;
};
mnsl_spirv_MNSLSPIRVPrinter.__name__ = true;
mnsl_spirv_MNSLSPIRVPrinter.__super__ = mnsl_MNSLPrinter;
mnsl_spirv_MNSLSPIRVPrinter.prototype = $extend(mnsl_MNSLPrinter.prototype,{
	convString: function(str) {
		var bytes = haxe_io_Bytes.ofString(str + String.fromCodePoint(0));
		var words = [];
		var i = 0;
		while(i < bytes.length) {
			var word = 0;
			if(i < bytes.length) {
				word |= bytes.b[i];
			}
			if(i + 1 < bytes.length) {
				word |= bytes.b[i + 1] << 8;
			}
			if(i + 2 < bytes.length) {
				word |= bytes.b[i + 2] << 16;
			}
			if(i + 3 < bytes.length) {
				word |= bytes.b[i + 3] << 24;
			}
			words.push(word);
			i += 4;
		}
		return words;
	}
	,getType: function(type) {
		var t = this._types.keys();
		while(t.hasNext()) {
			var t1 = t.next();
			if(t1.equals(type)) {
				return this._types.h[t1.__id__];
			}
		}
		var id = this.assignId();
		this.emitDebugLabel(id,"" + type.toHumanString());
		this._types.set(type,id);
		if(type._arrayBaseType != null) {
			var tmp = type._arrayBaseType;
			var typeId = this.getType(tmp != null ? tmp : type);
			var arraySizeId = this.getConst(type._arraySize,new mnsl_analysis_MNSLType("Int"));
			this._typeInit.push({ id : id, op : 28, oper : [id,typeId,arraySizeId]});
			return id;
		}
		if(type._type == "Mat" + 2 || type._type == "Mat" + 3 || type._type == "Mat" + 4) {
			var w;
			switch(type._type) {
			case "Mat2":
				w = 2;
				break;
			case "Mat3":
				w = 3;
				break;
			case "Mat4":
				w = 4;
				break;
			default:
				w = -1;
			}
			var h;
			switch(type._type) {
			case "Mat2":
				h = 2;
				break;
			case "Mat3":
				h = 3;
				break;
			case "Mat4":
				h = 4;
				break;
			default:
				h = -1;
			}
			this._typeInit.push({ id : id, op : 24, oper : [id,this.getType(new mnsl_analysis_MNSLType("Vec" + w)),h]});
			return id;
		}
		if(type._type == "Vec" + 2 || type._type == "Vec" + 3 || type._type == "Vec" + 4) {
			var tmp = this._typeInit;
			var tmp1 = this.getType(new mnsl_analysis_MNSLType("Float"));
			var tmp2;
			switch(type._type) {
			case "Vec2":
				tmp2 = 2;
				break;
			case "Vec3":
				tmp2 = 3;
				break;
			case "Vec4":
				tmp2 = 4;
				break;
			default:
				tmp2 = -1;
			}
			tmp.push({ id : id, op : 23, oper : [id,tmp1,tmp2]});
			return id;
		}
		var typeStr = type.toString();
		switch(typeStr) {
		case "Bool":
			this._typeInit.push({ id : id, op : 20, oper : [id]});
			break;
		case "CubeSampler":
			var sampledId = id;
			this._typeInit.push({ id : id, op : 25, oper : [id,this.getType(new mnsl_analysis_MNSLType("Float")),3,0,0,0,1,0]});
			id = this.assignId();
			this._typeInit.push({ id : id, op : 27, oper : [id,sampledId]});
			this.emitDebugLabel(sampledId,"TCubeSamplerImage");
			break;
		case "Float":
			this._typeInit.push({ id : id, op : 22, oper : [id,32]});
			break;
		case "Int":
			this._typeInit.push({ id : id, op : 21, oper : [id,32,1]});
			break;
		case "Sampler":
			var sampledId = id;
			this._typeInit.push({ id : id, op : 25, oper : [id,this.getType(new mnsl_analysis_MNSLType("Float")),1,0,0,0,1,0]});
			id = this.assignId();
			this._typeInit.push({ id : id, op : 27, oper : [id,sampledId]});
			this.emitDebugLabel(sampledId,"TSamplerImage");
			break;
		case "Void":
			this._typeInit.push({ id : id, op : 19, oper : [id]});
			break;
		default:
			throw haxe_Exception.thrown("Invalid type: " + typeStr);
		}
		return id;
	}
	,getConst: function(v,type) {
		var key = type.toString() + ":" + Std.string(v);
		if(Object.prototype.hasOwnProperty.call(this._constants.h,key)) {
			return this._constants.h[key].id;
		}
		var id = this.assignId();
		if(type._type == "Bool") {
			var data = { id : id, op : v == true ? 41 : 42, oper : [this.getType(type),id]};
			this._constants.h[key] = data;
			this._constInit.push(data);
			return id;
		}
		if(type._type == "Int") {
			var data = { id : id, op : 43, oper : [this.getType(type),id,v | 0]};
			this._constants.h[key] = data;
			this._constInit.push(data);
			return id;
		}
		if(type._type == "Float") {
			var data = { id : id, op : 43, oper : [this.getType(type),id,haxe_io_FPHelper.floatToI32(v)]};
			this._constInit.push(data);
			this._constants.h[key] = data;
			return id;
		}
		throw haxe_Exception.thrown("Unhandled constant type: " + Std.string(type) + " with value: " + Std.string(v));
	}
	,getPtr: function(id,storageClass) {
		var key = "" + id + ":" + storageClass;
		if(Object.prototype.hasOwnProperty.call(this._ptrTypes.h,key)) {
			return this._ptrTypes.h[key];
		}
		var typeId = this.assignId();
		this._ptrInit.push({ id : typeId, typeId : id, storageClass : storageClass});
		this._ptrTypes.h[key] = typeId;
		return typeId;
	}
	,getExtGlslStd: function() {
		if(this._glslExtId == -1) {
			this._glslExtId = this.assignId();
			this.emitInstruction(11,[this._glslExtId].concat(this.convString("GLSL.std.450")));
		}
		return this._glslExtId;
	}
	,getFunctionType: function(ret,params) {
		var key = ret.toString() + ":";
		var result = new Array(params.length);
		var _g = 0;
		var _g1 = params.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = params[i].toString();
		}
		var key1 = key + result.join(",");
		if(Object.prototype.hasOwnProperty.call(this._functionTypes.h,key1)) {
			return this._functionTypes.h[key1];
		}
		var _g = [];
		var _g1 = 0;
		while(_g1 < params.length) {
			var p = params[_g1];
			++_g1;
			_g.push(this.getType(p));
		}
		var paramTypes = _g;
		var retTypeId = this.getType(ret);
		var typeId = this.assignId();
		this._typeInit.push({ id : typeId, op : 33, oper : [typeId,retTypeId].concat(paramTypes)});
		this._functionTypes.h[key1] = typeId;
		return typeId;
	}
	,getShaderData: function(name,kind) {
		var _g = 0;
		var _g1 = this._decorations;
		while(_g < _g1.length) {
			var data = _g1[_g];
			++_g;
			if(data.kind == kind && data.name == name) {
				return data.id;
			}
		}
		return 0;
	}
	,getVarBaseName: function(on) {
		switch(on._hx_index) {
		case 5:
			var name = on.name;
			var type = on.type;
			var info = on.info;
			return name;
		case 17:
			var on1 = on.on;
			var field = on.field;
			var type = on.type;
			var info = on.info;
			return this.getVarBaseName(on1);
		case 18:
			var on1 = on.on;
			var index = on.index;
			var info = on.info;
			return this.getVarBaseName(on1);
		default:
			throw haxe_Exception.thrown("Invalid node for variable base: " + Std.string(on));
		}
	}
	,getVar: function(on,scope,requirePtr) {
		if(requirePtr == null) {
			requirePtr = false;
		}
		var _gthis = this;
		var stack = [];
		var currScope = scope;
		var currIsParam = false;
		var currRetId = 0;
		var currIsShaderData = false;
		var currShaderDataKind = mnsl_parser_MNSLShaderDataKind.Input;
		var currIsVecAccess = false;
		var currStorageClass = 7;
		var lastType = new mnsl_analysis_MNSLType("Void");
		var iterNode = null;
		iterNode = function(node) {
			switch(node._hx_index) {
			case 1:
				var iterName = node.name;
				var iterArgs = node.args;
				var iterRet = node.returnType;
				var iterInfo = node.info;
				stack.push({ name : "__mnsl_eval_tmp", type : iterRet, node : node, arrayIndex : null});
				break;
			case 5:
				var iterName = node.name;
				var iterType = node.type;
				var iterInfo = node.info;
				stack.push({ name : iterName, type : iterType, node : node, arrayIndex : null});
				break;
			case 17:
				var iterOn = node.on;
				var iterField = node.field;
				var iterType = node.type;
				var iterInfo = node.info;
				iterNode(iterOn);
				stack.push({ name : iterField, type : iterType, node : node, arrayIndex : null});
				break;
			case 18:
				var iterOn = node.on;
				var iterIndex = node.index;
				var iterInfo = node.info;
				iterNode(iterOn);
				stack.push({ name : "__mnsl_array_access", type : mnsl_analysis_MNSLAnalyser.getType(node), node : node, arrayIndex : iterIndex});
				break;
			default:
				throw haxe_Exception.thrown("Invalid node for variable access: " + Std.string(node));
			}
		};
		var enter = function(name,type,node,isLast,arrayIndex) {
			var varDef = currScope.variables.h[name];
			if((type._type == "Vec" + 2 || type._type == "Vec" + 3 || type._type == "Vec" + 4) && !isLast) {
				currIsVecAccess = true;
			}
			if(currIsShaderData) {
				var shData = _gthis.getShaderData(name,currShaderDataKind);
				if(shData == 0) {
					throw haxe_Exception.thrown("Shader data not found: " + name + " of kind " + Std.string(currShaderDataKind));
				}
				currRetId = shData;
				currIsShaderData = false;
				currIsParam = false;
				lastType = type;
				return;
			}
			if(name == "__mnsl_eval_tmp") {
				var funcRet = _gthis.emitNode(node,scope);
				currRetId = funcRet;
				currIsParam = true;
				lastType = type;
				return;
			}
			if(name == "__mnsl_array_access") {
				var indexId = _gthis.emitNode(arrayIndex,scope);
				var resId = _gthis.assignId();
				if(currIsParam) {
					throw haxe_Exception.thrown("Cannot get pointer to array access of a temporary value");
				}
				_gthis.emitInstruction(65,[_gthis.getPtr(_gthis.getType(type),currStorageClass),resId,currRetId,indexId]);
				currRetId = resId;
				currIsParam = false;
				lastType = type;
				return;
			}
			if(name == "input" || name == "output" || name == "uniform") {
				var varKind;
				switch(name) {
				case "input":
					varKind = mnsl_parser_MNSLShaderDataKind.Input;
					break;
				case "output":
					varKind = mnsl_parser_MNSLShaderDataKind.Output;
					break;
				case "uniform":
					varKind = mnsl_parser_MNSLShaderDataKind.Uniform;
					break;
				default:
					varKind = null;
				}
				currIsParam = false;
				currIsShaderData = true;
				currShaderDataKind = varKind;
				if(varKind == null) {
					throw haxe_Exception.thrown("Invalid shader data kind: " + Std.string(varKind));
				} else {
					switch(varKind._hx_index) {
					case 0:
						currStorageClass = 1;
						break;
					case 1:
						currStorageClass = 3;
						break;
					case 2:
						currStorageClass = 0;
						break;
					}
				}
				lastType = type;
				return;
			}
			if(currIsVecAccess && isLast) {
				var _this = name.split("");
				var result = new Array(_this.length);
				var _g = 0;
				var _g1 = _this.length;
				while(_g < _g1) {
					var i = _g++;
					result[i] = _gthis._componentList.indexOf(_this[i]);
				}
				var componentsIdxList = result;
				if(componentsIdxList.length == 0) {
					throw haxe_Exception.thrown("Invalid vector access: " + name);
				}
				var _g = 0;
				while(_g < componentsIdxList.length) {
					var comp = componentsIdxList[_g];
					++_g;
					if(comp < 0 || comp >= _gthis._componentList.length) {
						throw haxe_Exception.thrown("Invalid vector component index: " + comp + " in " + name);
					}
				}
				if(requirePtr) {
					if(componentsIdxList.length == 1) {
						var accessId = _gthis.assignId();
						var basePtr = currRetId;
						if(currIsParam) {
							throw haxe_Exception.thrown("Cannot get pointer to vector component of a temporary value");
						}
						_gthis.emitInstruction(65,[_gthis.getPtr(_gthis.getType(new mnsl_analysis_MNSLType("Float")),7),accessId,basePtr,_gthis.getConst(componentsIdxList[0],new mnsl_analysis_MNSLType("Int"))]);
						currRetId = accessId;
						currIsParam = false;
						lastType = type;
						return;
					} else {
						var swizzleId = _gthis.assignId();
						var basePtr = currRetId;
						if(currIsParam) {
							throw haxe_Exception.thrown("Cannot get pointer to vector component of a temporary value");
						}
						currScope.swizzlePointers.h[swizzleId] = { basePtr : basePtr, components : componentsIdxList, vectorType : lastType};
						currRetId = swizzleId;
						currIsParam = false;
						lastType = type;
						return;
					}
				}
				var vecId = currRetId;
				if(!currIsParam) {
					vecId = _gthis.assignId();
					_gthis.emitInstruction(61,[_gthis.getType(lastType),vecId,currRetId]);
				}
				currRetId = _gthis.assignId();
				currIsParam = true;
				lastType = type;
				if(componentsIdxList.length == 1) {
					_gthis.emitInstruction(81,[_gthis.getType(new mnsl_analysis_MNSLType("Float")),currRetId,vecId,componentsIdxList[0]]);
				} else {
					_gthis.emitInstruction(79,[_gthis.getType(type),currRetId,vecId,vecId].concat(componentsIdxList));
				}
				return;
			}
			if(varDef == null) {
				var result = new Array(stack.length);
				var _g = 0;
				var _g1 = stack.length;
				while(_g < _g1) {
					var i = _g++;
					result[i] = stack[i].name;
				}
				throw haxe_Exception.thrown("Undefined variable: " + result.join("."));
			} else {
				currRetId = varDef.id;
				currIsParam = varDef.isParam;
				lastType = type;
			}
		};
		iterNode(on);
		var idx = 0;
		var _g = 0;
		while(_g < stack.length) {
			var entry = stack[_g];
			++_g;
			enter(entry.name,entry.type,entry.node,idx == stack.length - 1,entry.arrayIndex);
			++idx;
		}
		if(requirePtr && currIsParam) {
			if(stack.length == 1 && Object.prototype.hasOwnProperty.call(scope.variables.h,"__mnsl_param_" + stack[0].name)) {
				return { id : scope.variables.h["__mnsl_param_" + stack[0].name].id, isParam : false};
			}
			var result = new Array(stack.length);
			var _g = 0;
			var _g1 = stack.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = stack[i].name;
			}
			var accessPath = result.join(".");
			throw haxe_Exception.thrown("Cannot get pointer to computed value: " + accessPath);
		}
		if(requirePtr && !currIsParam) {
			return { id : currRetId, isParam : false};
		}
		if(!requirePtr && !currIsParam) {
			var loadId = this.assignId();
			this.emitInstruction(61,[this.getType(lastType),loadId,currRetId]);
			return { id : loadId, isParam : true};
		}
		return { id : currRetId, isParam : currIsParam};
	}
	,assignId: function() {
		return this._idCount++;
	}
	,emitInstruction: function(op,operands) {
		this._instructions.push([operands.length + 1 << 16 | op].concat(operands));
		return this._instructions.length - 1;
	}
	,insertInstruction: function(index,op,operands) {
		if(index < 0 || index > this._instructions.length) {
			throw haxe_Exception.thrown("Index out of bounds for instruction insertion: " + index);
		}
		var instruction = [operands.length + 1 << 16 | op].concat(operands);
		this._instructions.splice(index,0,instruction);
		return index;
	}
	,editInstruction: function(index,op,operands) {
		if(index < 0 || index >= this._instructions.length) {
			throw haxe_Exception.thrown("Index out of bounds for instruction edit: " + index);
		}
		this._instructions[index] = [operands.length + 1 << 16 | op].concat(operands);
	}
	,emitDebugLabel: function(id,name) {
		this._debugLabels.h[id] = name;
	}
	,emitDecoration: function(name,kind,id,decoration,params) {
		this._decorations.push({ id : id, decoration : decoration, oper : params, kind : kind, name : name});
	}
	,emitShaderData: function() {
		var locationCount = 0;
		var internalData = [new mnsl_parser_MNSLShaderData(mnsl_parser_MNSLShaderDataKind.Input,new mnsl_analysis_MNSLType("Int"),"VertexID",-1),new mnsl_parser_MNSLShaderData(mnsl_parser_MNSLShaderDataKind.Input,new mnsl_analysis_MNSLType("Int"),"InstanceID",-1),new mnsl_parser_MNSLShaderData(mnsl_parser_MNSLShaderDataKind.Input,new mnsl_analysis_MNSLType("Vec4"),"FragCoord",-1),new mnsl_parser_MNSLShaderData(mnsl_parser_MNSLShaderDataKind.Input,new mnsl_analysis_MNSLType("Bool"),"FrontFacing",-1),new mnsl_parser_MNSLShaderData(mnsl_parser_MNSLShaderDataKind.Input,new mnsl_analysis_MNSLType("Float"),"FragDepth",-1),new mnsl_parser_MNSLShaderData(mnsl_parser_MNSLShaderDataKind.Output,new mnsl_analysis_MNSLType("Vec4"),"Position",-1),new mnsl_parser_MNSLShaderData(mnsl_parser_MNSLShaderDataKind.Output,new mnsl_analysis_MNSLType("Float"),"PointSize",-1)];
		var _g = 0;
		var _g1 = this._context.getShaderData().concat(internalData);
		while(_g < _g1.length) {
			var data = _g1[_g];
			++_g;
			var typeId = this.getType(data.type);
			var varId = this.assignId();
			var varName;
			var storageClass;
			switch(data.kind._hx_index) {
			case 0:
				storageClass = 1;
				varName = "in_" + data.name;
				break;
			case 1:
				storageClass = 3;
				varName = "out_" + data.name;
				break;
			case 2:
				storageClass = 0;
				varName = "u_" + data.name;
				break;
			}
			this.emitInstruction(59,[this.getPtr(typeId,storageClass),varId,storageClass]);
			this.emitDebugLabel(varId,varName);
			if(data.kind == mnsl_parser_MNSLShaderDataKind.Output) {
				switch(data.name) {
				case "PointSize":
					this.emitDecoration("PointSize",data.kind,varId,11,[1]);
					continue;
				case "Position":
					this.emitDecoration("Position",data.kind,varId,11,[0]);
					continue;
				default:
					this.emitDecoration(data.name,data.kind,varId,30,[locationCount]);
					++locationCount;
				}
			}
			if(data.kind == mnsl_parser_MNSLShaderDataKind.Input) {
				switch(data.name) {
				case "FragCoord":
					this.emitDecoration("FragCoord",data.kind,varId,11,[15]);
					continue;
				case "FragDepth":
					this.emitDecoration("FragDepth",data.kind,varId,11,[22]);
					continue;
				case "FrontFacing":
					this.emitDecoration("FrontFacing",data.kind,varId,11,[17]);
					continue;
				case "InstanceID":
					this.emitDecoration("InstanceID",data.kind,varId,11,[6]);
					continue;
				case "VertexID":
					this.emitDecoration("VertexID",data.kind,varId,11,[5]);
					continue;
				default:
					this.emitDecoration(data.name,data.kind,varId,30,[locationCount]);
					++locationCount;
				}
			}
			if(data.kind == mnsl_parser_MNSLShaderDataKind.Uniform) {
				this.emitDecoration(data.name,data.kind,varId,0,[]);
			}
		}
	}
	,preEmit: function(ast,scope) {
		var _g = 0;
		while(_g < ast.length) {
			var node = ast[_g];
			++_g;
			switch(node._hx_index) {
			case 0:
				var name = node.name;
				var returnType = node.returnType;
				var $arguments = node.$arguments;
				var body = node.body;
				var info = node.info;
				var _g1 = [];
				var _g2 = 0;
				while(_g2 < $arguments.length) {
					var arg = $arguments[_g2];
					++_g2;
					_g1.push(arg.type);
				}
				this.getFunctionType(returnType,_g1);
				break;
			case 3:
				var name1 = node.name;
				var type = node.type;
				var value = node.value;
				var info1 = node.info;
				this.getPtr(this.getType(type),7);
				if(scope != null) {
					var varId = this.assignId();
					var ptrId = this.getPtr(this.getType(type),7);
					this.emitInstruction(59,[ptrId,varId,7]);
					this.emitDebugLabel(varId,name1);
					scope.setVariable(name1,varId);
				}
				break;
			case 4:
				var name2 = node.name;
				var value1 = node.value;
				var info2 = node.info;
				var tmp;
				var tmp1;
				var tmp2;
				if(scope != null) {
					var this1 = scope.variables;
					var key = this.getVarBaseName(name2);
					tmp2 = Object.prototype.hasOwnProperty.call(this1.h,key);
				} else {
					tmp2 = false;
				}
				if(tmp2) {
					var this2 = scope.variables;
					var key1 = this.getVarBaseName(name2);
					tmp1 = this2.h[key1].isParam;
				} else {
					tmp1 = false;
				}
				if(tmp1) {
					var this3 = scope.variables;
					var key2 = "__mnsl_param_" + this.getVarBaseName(name2);
					tmp = !Object.prototype.hasOwnProperty.call(this3.h,key2);
				} else {
					tmp = false;
				}
				if(tmp) {
					var varId1 = this.assignId();
					var ptrId1 = this.getPtr(this.getType(mnsl_analysis_MNSLAnalyser.getType(value1)),7);
					this.emitInstruction(59,[ptrId1,varId1,7]);
					this.emitDebugLabel(varId1,"__mnsl_param_" + this.getVarBaseName(name2));
					scope.setVariable("__mnsl_param_" + this.getVarBaseName(name2),varId1);
				}
				break;
			case 24:
				var value2 = node.value;
				var info3 = node.info;
				this.getConst(Std.parseInt(value2),new mnsl_analysis_MNSLType("Int"));
				break;
			case 25:
				var value3 = node.value;
				var info4 = node.info;
				this.getConst(parseFloat(value3),new mnsl_analysis_MNSLType("Float"));
				break;
			case 27:
				var value4 = node.value;
				var info5 = node.info;
				this.getConst(value4,new mnsl_analysis_MNSLType("Bool"));
				break;
			default:
			}
			var params = Type.enumParameters(node);
			var _g3 = 0;
			while(_g3 < params.length) {
				var p = params[_g3];
				++_g3;
				if(((p) instanceof Array) && p[0] != null && js_Boot.__instanceof(p[0],mnsl_parser_MNSLNode)) {
					this.preEmit(p,scope);
				} else if(js_Boot.__instanceof(p,mnsl_parser_MNSLNode)) {
					this.preEmit([p],scope);
				}
			}
		}
	}
	,emitBody: function(body,scope) {
		var _g = 0;
		while(_g < body.length) {
			var node = body[_g];
			++_g;
			this.emitNode(node,scope);
		}
	}
	,emitNode: function(node,scope) {
		switch(node._hx_index) {
		case 0:
			var name = node.name;
			var returnType = node.returnType;
			var $arguments = node.$arguments;
			var body = node.body;
			var info = node.info;
			return this.emitFunctionDecl(name,returnType,$arguments,body,info,scope);
		case 1:
			var name = node.name;
			var args = node.args;
			var returnType = node.returnType;
			var info = node.info;
			return this.emitFunctionCall(name,args,returnType,info,scope);
		case 2:
			var value = node.value;
			var type = node.type;
			var info = node.info;
			return this.emitReturn(value,type,info,scope);
		case 3:
			var name = node.name;
			var type = node.type;
			var value = node.value;
			var info = node.info;
			return this.emitVariableDecl(name,type,value,info,scope);
		case 4:
			var name = node.name;
			var value = node.value;
			var info = node.info;
			return this.emitVariableAssign(name,value,info,scope);
		case 5:
			var name = node.name;
			var type = node.type;
			var info = node.info;
			return this.emitIdentifier(name,type,info,scope);
		case 9:
			var left = node.left;
			var op = node.op;
			var right = node.right;
			var type = node.type;
			var info = node.info;
			return this.emitBinaryOp(left,op,right,type,info,scope);
		case 10:
			var op = node.op;
			var right = node.right;
			var info = node.info;
			return this.emitUnaryOp(op,right,info,scope);
		case 15:
			var node1 = node.node;
			var info = node.info;
			return this.emitNode(node1,scope);
		case 16:
			var body = node.body;
			var info = node.info;
			this.emitBody(body,scope);
			return 0;
		case 17:
			var on = node.on;
			var field = node.field;
			var type = node.type;
			var info = node.info;
			return this.emitStructAccess(on,field,type,info,scope);
		case 18:
			var on = node.on;
			var index = node.index;
			var info = node.info;
			return this.emitArrayAccess(on,index,mnsl_analysis_MNSLAnalyser.getType(node),info,scope);
		case 19:
			var on = node.on;
			var from = node.from;
			var to = node.to;
			return this.emitTypeCast(on,from,to,scope);
		case 22:
			var comp = node.components;
			var nodes = node.nodes;
			var info = node.info;
			return this.emitVectorCreation(comp,nodes,info,scope);
		case 23:
			var on = node.on;
			var from = node.fromComponents;
			var to = node.toComponents;
			return this.emitVectorConversion(on,from,to,scope);
		case 24:
			var value = node.value;
			var info = node.info;
			return this.getConst(Std.parseInt(value),new mnsl_analysis_MNSLType("Int"));
		case 25:
			var value = node.value;
			var info = node.info;
			return this.getConst(parseFloat(value),new mnsl_analysis_MNSLType("Float"));
		case 27:
			var value = node.value;
			var info = node.info;
			return this.getConst(value,new mnsl_analysis_MNSLType("Bool"));
		default:
			haxe_Log.trace("Unhandled node",{ fileName : "mnsl/spirv/MNSLSPIRVPrinter.hx", lineNumber : 725, className : "mnsl.spirv.MNSLSPIRVPrinter", methodName : "emitNode", customParams : [node]});
			return 0;
		}
	}
	,emitStructAccess: function(on,field,type,info,scope) {
		var varDef = this.getVar(mnsl_parser_MNSLNode.StructAccess(on,field,type,info),scope);
		if(varDef.isParam) {
			return varDef.id;
		}
		var typeId = this.getType(type);
		var resultId = this.assignId();
		this.emitInstruction(61,[typeId,resultId,varDef.id]);
		return resultId;
	}
	,emitArrayAccess: function(on,index,type,info,scope) {
		var varDef = this.getVar(mnsl_parser_MNSLNode.ArrayAccess(on,index,info),scope);
		if(varDef.isParam) {
			return varDef.id;
		}
		var typeId = this.getType(type);
		var resultId = this.assignId();
		var indexId = this.emitNode(index,scope);
		this.emitInstruction(61,[typeId,resultId,varDef.id]);
		this.emitInstruction(65,[this.getPtr(typeId,7),resultId,resultId,indexId]);
		return resultId;
	}
	,emitIdentifier: function(name,type,info,scope) {
		var varDef = this.getVar(mnsl_parser_MNSLNode.Identifier(name,type,info),scope);
		if(varDef.isParam) {
			return varDef.id;
		}
		var typeId = this.getType(type);
		var resultId = this.assignId();
		this.emitInstruction(61,[typeId,resultId,varDef.id]);
		return resultId;
	}
	,emitVariableAssign: function(on,value,info,scope) {
		var varDef = this.getVar(on,scope,true);
		var valueId = this.emitNode(value,scope);
		if(scope.swizzlePointers.h.hasOwnProperty(varDef.id)) {
			return this.emitSwizzleStore(varDef.id,valueId,scope);
		}
		this.emitInstruction(62,[varDef.id,valueId]);
		return varDef.id;
	}
	,emitSwizzleStore: function(swizzleId,valueId,scope) {
		var swizzleInfo = scope.swizzlePointers.h[swizzleId];
		if(swizzleInfo == null) {
			throw haxe_Exception.thrown("Invalid swizzle pointer: " + swizzleId);
		}
		var originalVecId = this.assignId();
		this.emitInstruction(61,[this.getType(swizzleInfo.vectorType),originalVecId,swizzleInfo.basePtr]);
		var newVecId = this.assignId();
		var originalSize;
		switch(swizzleInfo.vectorType._type) {
		case "Vec2":
			originalSize = 2;
			break;
		case "Vec3":
			originalSize = 3;
			break;
		case "Vec4":
			originalSize = 4;
			break;
		default:
			originalSize = -1;
		}
		var shuffleIndices = [];
		var _g = 0;
		var _g1 = originalSize;
		while(_g < _g1) {
			var i = _g++;
			var componentInSwizzle = swizzleInfo.components.indexOf(i);
			if(componentInSwizzle >= 0) {
				shuffleIndices.push(originalSize + componentInSwizzle);
			} else {
				shuffleIndices.push(i);
			}
		}
		this.emitInstruction(79,[this.getType(swizzleInfo.vectorType),newVecId,originalVecId,valueId].concat(shuffleIndices));
		this.emitInstruction(62,[swizzleInfo.basePtr,newVecId]);
		scope.swizzlePointers.remove(swizzleId);
		return swizzleInfo.basePtr;
	}
	,emitVariableDecl: function(name,type,value,info,scope) {
		if(!Object.prototype.hasOwnProperty.call(scope.variables.h,name)) {
			throw haxe_Exception.thrown("Pre-emit error: Variable not found in scope: " + name);
		}
		var varId = scope.variables.h[name];
		if(value != null) {
			var valueId = this.emitNode(value,scope);
			this.emitInstruction(62,[varId.id,valueId]);
		}
		return varId.id;
	}
	,emitVectorConversion: function(on,fromComp,toComp,scope) {
		var onId = this.emitNode(on,scope);
		var fromType = new mnsl_analysis_MNSLType("Vec" + fromComp);
		var toType = new mnsl_analysis_MNSLType("Vec" + toComp);
		if(fromComp == toComp) {
			return onId;
		} else if(fromComp < toComp) {
			var resultId = this.assignId();
			var targetTypeId = this.getType(toType);
			var componentIds = [];
			var scalarType = this.getType(new mnsl_analysis_MNSLType("Float"));
			var _g = 0;
			var _g1 = fromComp;
			while(_g < _g1) {
				var i = _g++;
				var componentId = this.assignId();
				this.emitInstruction(81,[scalarType,componentId,onId,i]);
				componentIds.push(componentId);
			}
			var _g = fromComp;
			var _g1 = toComp;
			while(_g < _g1) {
				var i = _g++;
				if(i == toComp - 1) {
					componentIds.push(this.getConst(1.0,new mnsl_analysis_MNSLType("Float")));
				} else {
					componentIds.push(this.getConst(0.0,new mnsl_analysis_MNSLType("Float")));
				}
			}
			this.emitInstruction(80,[targetTypeId,resultId].concat(componentIds));
			return resultId;
		} else {
			var resultId = this.assignId();
			var targetTypeId = this.getType(toType);
			var shuffleList = [];
			var _g = 0;
			var _g1 = toComp;
			while(_g < _g1) {
				var i = _g++;
				shuffleList.push(i);
			}
			this.emitInstruction(79,[targetTypeId,resultId,onId,onId].concat(shuffleList));
			return resultId;
		}
	}
	,emitVectorCreation: function(comp,nodes,info,scope) {
		if(nodes.length != comp && nodes.length != 1) {
			throw haxe_Exception.thrown("Vector creation expects " + comp + " components, but got " + nodes.length);
		}
		var type = new mnsl_analysis_MNSLType("Vec" + comp);
		var typeId = this.getType(type);
		var resId = this.assignId();
		if(nodes.length == 1) {
			var scalarId = this.emitTypeCast(nodes[0],mnsl_analysis_MNSLAnalyser.getType(nodes[0]),new mnsl_analysis_MNSLType("Float"),scope);
			var _g = [];
			var _g1 = 0;
			var _g2 = comp;
			while(_g1 < _g2) {
				var i = _g1++;
				_g.push(scalarId);
			}
			var componentIds = _g;
			this.emitInstruction(80,[typeId,resId].concat(componentIds));
			return resId;
		}
		var _g = [];
		var _g1 = 0;
		while(_g1 < nodes.length) {
			var n = nodes[_g1];
			++_g1;
			_g.push(this.emitTypeCast(n,mnsl_analysis_MNSLAnalyser.getType(n),new mnsl_analysis_MNSLType("Float"),scope));
		}
		this.emitInstruction(80,[typeId,resId].concat(_g));
		return resId;
	}
	,emitTypeCast: function(on,from,to,scope) {
		var onId = this.emitNode(on,scope);
		if(from.equals(to)) {
			return onId;
		}
		var resId = this.assignId();
		var targetType = this.getType(to);
		if(from._type == "Float" && to._type == "Int") {
			this.emitInstruction(110,[targetType,resId,onId]);
			return resId;
		}
		if(from._type == "Int" && to._type == "Float") {
			haxe_Log.trace(on,{ fileName : "mnsl/spirv/MNSLSPIRVPrinter.hx", lineNumber : 916, className : "mnsl.spirv.MNSLSPIRVPrinter", methodName : "emitTypeCast"});
			this.emitInstruction(111,[targetType,resId,onId]);
			return resId;
		}
		this.emitInstruction(124,[targetType,resId,onId]);
		return resId;
	}
	,emitUnaryOp: function(op,right,info,scope) {
		var rightId = this.emitNode(right,scope);
		var resultId = this.assignId();
		switch(op._hx_index) {
		case 14:
			var _g = op.info;
			var type = mnsl_analysis_MNSLAnalyser.getType(right);
			if(type._type == "Float" || (type._type == "Vec" + 2 || type._type == "Vec" + 3 || type._type == "Vec" + 4)) {
				this.emitInstruction(127,[this.getType(type),resultId,rightId]);
			} else if(type._type == "Int") {
				this.emitInstruction(126,[this.getType(type),resultId,rightId]);
			} else {
				throw haxe_Exception.thrown("Unsupported type for unary minus: " + type.toHumanString());
			}
			break;
		case 15:
			var _g = op.info;
			this._idCount--;
			return rightId;
		case 32:
			var _g = op.info;
			this.emitInstruction(168,[this.getType(new mnsl_analysis_MNSLType("Bool")),resultId,rightId]);
			break;
		default:
			throw haxe_Exception.thrown("Unsupported unary operator: " + Std.string(op));
		}
		return resultId;
	}
	,emitBinaryOp: function(left,op,right,type,info,scope) {
		var leftId = this.emitNode(left,scope);
		var rightId = this.emitNode(right,scope);
		var resultId = this.assignId();
		switch(op._hx_index) {
		case 14:
			var _g = op.info;
			if(type._type == "Float" || (type._type == "Vec" + 2 || type._type == "Vec" + 3 || type._type == "Vec" + 4)) {
				this.emitInstruction(131,[this.getType(type),resultId,leftId,rightId]);
			} else if(type._type == "Int") {
				this.emitInstruction(130,[this.getType(type),resultId,leftId,rightId]);
			} else {
				throw haxe_Exception.thrown("Unsupported type for subtraction: " + type.toHumanString());
			}
			break;
		case 15:
			var _g = op.info;
			if(type._type == "Float" || (type._type == "Vec" + 2 || type._type == "Vec" + 3 || type._type == "Vec" + 4)) {
				this.emitInstruction(129,[this.getType(type),resultId,leftId,rightId]);
			} else if(type._type == "Int") {
				this.emitInstruction(128,[this.getType(type),resultId,leftId,rightId]);
			} else {
				throw haxe_Exception.thrown("Unsupported type for addition: " + type.toHumanString());
			}
			break;
		case 17:
			var _g = op.info;
			if(type._type == "Float" || (type._type == "Vec" + 2 || type._type == "Vec" + 3 || type._type == "Vec" + 4)) {
				var leftType = mnsl_analysis_MNSLAnalyser.getType(left);
				var rightType = mnsl_analysis_MNSLAnalyser.getType(right);
				if(leftType._type == "Int") {
					var leftConvId = this.assignId();
					this.emitInstruction(111,[this.getType(new mnsl_analysis_MNSLType("Float")),leftConvId,leftId]);
					leftId = leftConvId;
				}
				if(rightType._type == "Int") {
					var rightConvId = this.assignId();
					this.emitInstruction(111,[this.getType(new mnsl_analysis_MNSLType("Float")),rightConvId,rightId]);
					rightId = rightConvId;
				}
				this.emitInstruction(136,[this.getType(type),resultId,leftId,rightId]);
			} else if(type._type == "Int") {
				this.emitInstruction(135,[this.getType(type),resultId,leftId,rightId]);
			} else {
				throw haxe_Exception.thrown("Unsupported type for division: " + type.toHumanString());
			}
			break;
		case 18:
			var _g = op.info;
			if(type._type == "Float" || (type._type == "Vec" + 2 || type._type == "Vec" + 3 || type._type == "Vec" + 4)) {
				this.emitInstruction(133,[this.getType(type),resultId,leftId,rightId]);
			} else if(type._type == "Int") {
				this.emitInstruction(132,[this.getType(type),resultId,leftId,rightId]);
			} else {
				throw haxe_Exception.thrown("Unsupported type for multiplication: " + type.toHumanString());
			}
			break;
		case 19:
			var _g = op.info;
			if(type._type == "Int") {
				this.emitInstruction(138,[this.getType(type),resultId,leftId,rightId]);
			} else {
				throw haxe_Exception.thrown("Unsupported type for modulo: " + type.toHumanString());
			}
			break;
		case 22:
			var _g = op.info;
			if(type._type == "Float" || (type._type == "Vec" + 2 || type._type == "Vec" + 3 || type._type == "Vec" + 4)) {
				this.emitInstruction(180,[this.getType(new mnsl_analysis_MNSLType("Bool")),resultId,leftId,rightId]);
			} else if(type._type == "Int") {
				this.emitInstruction(170,[this.getType(new mnsl_analysis_MNSLType("Bool")),resultId,leftId,rightId]);
			} else {
				throw haxe_Exception.thrown("Unsupported type for equality: " + type.toHumanString());
			}
			break;
		case 25:
			var _g = op.info;
			if(type._type == "Bool") {
				this.emitInstruction(167,[this.getType(new mnsl_analysis_MNSLType("Bool")),resultId,leftId,rightId]);
			} else {
				throw haxe_Exception.thrown("Unsupported type for logical AND: " + type.toHumanString());
			}
			break;
		case 26:
			var _g = op.info;
			if(type._type == "Bool") {
				this.emitInstruction(166,[this.getType(new mnsl_analysis_MNSLType("Bool")),resultId,leftId,rightId]);
			} else {
				throw haxe_Exception.thrown("Unsupported type for logical OR: " + type.toHumanString());
			}
			break;
		case 27:
			var _g = op.info;
			if(type._type == "Float" || (type._type == "Vec" + 2 || type._type == "Vec" + 3 || type._type == "Vec" + 4)) {
				this.emitInstruction(184,[this.getType(new mnsl_analysis_MNSLType("Bool")),resultId,leftId,rightId]);
			} else if(type._type == "Int") {
				this.emitInstruction(177,[this.getType(new mnsl_analysis_MNSLType("Bool")),resultId,leftId,rightId]);
			} else {
				throw haxe_Exception.thrown("Unsupported type for less than: " + type.toHumanString());
			}
			break;
		case 28:
			var _g = op.info;
			if(type._type == "Float" || (type._type == "Vec" + 2 || type._type == "Vec" + 3 || type._type == "Vec" + 4)) {
				this.emitInstruction(186,[this.getType(new mnsl_analysis_MNSLType("Bool")),resultId,leftId,rightId]);
			} else if(type._type == "Int") {
				this.emitInstruction(173,[this.getType(new mnsl_analysis_MNSLType("Bool")),resultId,leftId,rightId]);
			} else {
				throw haxe_Exception.thrown("Unsupported type for greater than: " + type.toHumanString());
			}
			break;
		case 29:
			var _g = op.info;
			if(type._type == "Float" || (type._type == "Vec" + 2 || type._type == "Vec" + 3 || type._type == "Vec" + 4)) {
				this.emitInstruction(188,[this.getType(new mnsl_analysis_MNSLType("Bool")),resultId,leftId,rightId]);
			} else if(type._type == "Int") {
				this.emitInstruction(179,[this.getType(new mnsl_analysis_MNSLType("Bool")),resultId,leftId,rightId]);
			} else {
				throw haxe_Exception.thrown("Unsupported type for less than or equal: " + type.toHumanString());
			}
			break;
		case 30:
			var _g = op.info;
			if(type._type == "Float" || (type._type == "Vec" + 2 || type._type == "Vec" + 3 || type._type == "Vec" + 4)) {
				this.emitInstruction(190,[this.getType(new mnsl_analysis_MNSLType("Bool")),resultId,leftId,rightId]);
			} else if(type._type == "Int") {
				this.emitInstruction(175,[this.getType(new mnsl_analysis_MNSLType("Bool")),resultId,leftId,rightId]);
			} else {
				throw haxe_Exception.thrown("Unsupported type for greater than or equal: " + type.toHumanString());
			}
			break;
		case 31:
			var _g = op.info;
			if(type._type == "Float" || (type._type == "Vec" + 2 || type._type == "Vec" + 3 || type._type == "Vec" + 4)) {
				this.emitInstruction(182,[this.getType(new mnsl_analysis_MNSLType("Bool")),resultId,leftId,rightId]);
			} else if(type._type == "Int") {
				this.emitInstruction(171,[this.getType(new mnsl_analysis_MNSLType("Bool")),resultId,leftId,rightId]);
			} else {
				throw haxe_Exception.thrown("Unsupported type for not equal: " + type.toHumanString());
			}
			break;
		default:
			throw haxe_Exception.thrown("Unsupported binary operator: " + Std.string(op));
		}
		return resultId;
	}
	,emitFunctionDecl: function(name,returnType,$arguments,body,info,scope) {
		scope = scope.copy();
		var _g = [];
		var _g1 = 0;
		while(_g1 < $arguments.length) {
			var arg = $arguments[_g1];
			++_g1;
			_g.push(arg.type);
		}
		var typeId = this.getFunctionType(returnType,_g);
		var id = this.assignId();
		this.emitInstruction(54,[this.getType(returnType),id,0,typeId]);
		this.emitDebugLabel(id,name);
		var _g = 0;
		while(_g < $arguments.length) {
			var arg = $arguments[_g];
			++_g;
			var paramId = this.assignId();
			this.emitInstruction(55,[this.getType(arg.type),paramId]);
			this.emitDebugLabel(paramId,arg.name);
			scope.setParameter(arg.name,paramId);
		}
		this._functions.h[name] = id;
		this.emitInstruction(248,[this.assignId()]);
		this.preEmit(body,scope);
		this.emitBody(body,scope);
		if(returnType.equals(new mnsl_analysis_MNSLType("Void"))) {
			this.emitInstruction(253,[]);
		}
		this.emitInstruction(56,[]);
		if(name == "main") {
			this._entry = id;
		}
		return id;
	}
	,emitBuiltinFunctionCall: function(name,args,returnType,info,glslMapping,scope) {
		var _g = [];
		var _g1 = 0;
		while(_g1 < args.length) {
			var arg = args[_g1];
			++_g1;
			_g.push(this.emitNode(arg,scope));
		}
		var argIds = _g;
		var retId = this.assignId();
		var typeId = this.getType(returnType);
		switch(name) {
		case "dot":
			if(args.length != 2) {
				throw haxe_Exception.thrown("dot() requires 2 arguments");
			}
			this.emitInstruction(148,[typeId,retId].concat(argIds));
			return retId;
		case "mod":
			if(args.length != 2) {
				throw haxe_Exception.thrown("mod() requires 2 arguments");
			}
			this.emitInstruction(141,[typeId,retId].concat(argIds));
			return retId;
		case "texture":
			if(args.length != 2) {
				throw haxe_Exception.thrown("texture() requires sampler and texcoords");
			}
			this.emitInstruction(87,[typeId,retId].concat(argIds));
			return retId;
		default:
			var glslExtId = this.getExtGlslStd();
			var glslInst = glslMapping;
			this.emitInstruction(12,[typeId,retId,glslExtId,glslInst].concat(argIds));
			return retId;
		}
	}
	,emitFunctionCall: function(name,args,returnType,info,scope) {
		var _g = 0;
		var _g1 = this._glslFuncMap;
		while(_g < _g1.length) {
			var func = _g1[_g];
			++_g;
			if(func.name == name) {
				return this.emitBuiltinFunctionCall(name,args,returnType,info,func.mapping,scope);
			}
		}
		if(!Object.prototype.hasOwnProperty.call(this._functions.h,name)) {
			throw haxe_Exception.thrown("Function not found: " + name);
		}
		var funcId = this._functions.h[name];
		var _g = [];
		var _g1 = 0;
		while(_g1 < args.length) {
			var arg = args[_g1];
			++_g1;
			_g.push(this.emitNode(arg,scope));
		}
		var argIds = _g;
		var retId = this.assignId();
		this.emitInstruction(57,[this.getType(returnType),retId,funcId].concat(argIds));
		return retId;
	}
	,emitReturn: function(value,type,info,scope) {
		if(value._hx_index == 20) {
			var _g = value.info;
			this.emitInstruction(253,[]);
		} else {
			this.emitInstruction(254,[this.emitNode(value,scope)]);
		}
		return 0;
	}
	,getBytes: function() {
		return this._bin.getBytes();
	}
	,run: function() {
		this.emitInstruction(17,[1]);
		this.getExtGlslStd();
		this.emitInstruction(14,[0,1]);
		var entryInst = this.emitInstruction(15,[]);
		this.getType(new mnsl_analysis_MNSLType("Void"));
		this.getType(new mnsl_analysis_MNSLType("Bool"));
		this.getType(new mnsl_analysis_MNSLType("Int"));
		this.getType(new mnsl_analysis_MNSLType("Float"));
		this.getType(new mnsl_analysis_MNSLType("Vec2"));
		this.getType(new mnsl_analysis_MNSLType("Vec3"));
		this.getType(new mnsl_analysis_MNSLType("Vec4"));
		this.getType(new mnsl_analysis_MNSLType("Mat2"));
		this.getType(new mnsl_analysis_MNSLType("Mat3"));
		this.getType(new mnsl_analysis_MNSLType("Mat4"));
		this.getType(new mnsl_analysis_MNSLType("Sampler"));
		this.getType(new mnsl_analysis_MNSLType("CubeSampler"));
		var preShaderIdx = this._instructions.length;
		this.getConst(0.0,new mnsl_analysis_MNSLType("Float"));
		this.getConst(1.0,new mnsl_analysis_MNSLType("Float"));
		this.getConst(0,new mnsl_analysis_MNSLType("Int"));
		this.getConst(1,new mnsl_analysis_MNSLType("Int"));
		this.getConst(2,new mnsl_analysis_MNSLType("Int"));
		this.getConst(3,new mnsl_analysis_MNSLType("Int"));
		this.preEmit(this._ast);
		this.emitShaderData();
		this._ptrInit.reverse();
		this._constInit.reverse();
		this._typeInit.reverse();
		var _g = 0;
		var _g1 = this._ptrInit;
		while(_g < _g1.length) {
			var ptr = _g1[_g];
			++_g;
			this.insertInstruction(preShaderIdx,32,[ptr.id,ptr.storageClass,ptr.typeId]);
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = this._typeInit;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(v.op == 33) {
				_g.push(v);
			}
		}
		var functionTypes = _g;
		var _g = 0;
		while(_g < functionTypes.length) {
			var type = functionTypes[_g];
			++_g;
			this.insertInstruction(preShaderIdx,type.op,type.oper);
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = this._typeInit;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(v.op == 28) {
				_g.push(v);
			}
		}
		var arrayTypes = _g;
		var _g = 0;
		while(_g < arrayTypes.length) {
			var type = arrayTypes[_g];
			++_g;
			this.insertInstruction(preShaderIdx,type.op,type.oper);
		}
		var _g = 0;
		var _g1 = this._constInit;
		while(_g < _g1.length) {
			var $const = _g1[_g];
			++_g;
			this.insertInstruction(preShaderIdx,$const.op,$const.oper);
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = this._typeInit;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(v.op != 28 && v.op != 33) {
				_g.push(v);
			}
		}
		var basicTypes = _g;
		var _g = 0;
		while(_g < basicTypes.length) {
			var type = basicTypes[_g];
			++_g;
			this.insertInstruction(preShaderIdx,type.op,type.oper);
		}
		this.emitBody(this._ast,new mnsl_spirv_MNSLSPIRVScope(null,null));
		var debugLabels = Lambda.count(this._debugLabels);
		var label = this._debugLabels.keys();
		while(label.hasNext()) {
			var label1 = label.next();
			var name = this._debugLabels.h[label1];
			this.insertInstruction(entryInst + 1,5,[label1].concat(this.convString(name)));
		}
		var _g = 0;
		var _g1 = this._decorations;
		while(_g < _g1.length) {
			var decoration = _g1[_g];
			++_g;
			if(decoration.decoration == -1) {
				continue;
			}
			this.insertInstruction(entryInst + debugLabels + 1,71,[decoration.id,decoration.decoration].concat(decoration.oper));
		}
		if(this._entry == 0) {
			throw haxe_Exception.thrown("No entry point found in the SPIR-V module.");
		}
		var execModel;
		switch(this._config.shaderType) {
		case 0:
			execModel = 0;
			break;
		case 1:
			execModel = 4;
			break;
		default:
			throw haxe_Exception.thrown("Unsupported shader type: " + this._config.shaderType);
		}
		var tmp = [execModel,this._entry];
		var tmp1 = this.convString("main");
		var _g = [];
		var _g1 = 0;
		var _g2 = [];
		var _g3 = 0;
		var _g4 = this._decorations;
		while(_g3 < _g4.length) {
			var v = _g4[_g3];
			++_g3;
			if(v.kind == mnsl_parser_MNSLShaderDataKind.Input || v.kind == mnsl_parser_MNSLShaderDataKind.Output) {
				_g2.push(v);
			}
		}
		var _g3 = _g2;
		while(_g1 < _g3.length) {
			var data = _g3[_g1];
			++_g1;
			_g.push(data.id);
		}
		this.editInstruction(entryInst,15,tmp.concat(tmp1.concat(_g)));
		if(this._config.shaderType == 1) {
			this.insertInstruction(entryInst + 1,16,[this._entry,7]);
		}
		this._bin.writeInt32(119734787);
		this._bin.writeInt32(65536);
		this._bin.writeInt32(0);
		this._bin.writeInt32(this._idCount);
		this._bin.writeInt32(0);
		var _g = 0;
		var _g1 = this._instructions;
		while(_g < _g1.length) {
			var inst = _g1[_g];
			++_g;
			var _g2 = 0;
			while(_g2 < inst.length) {
				var word = inst[_g2];
				++_g2;
				this._bin.writeInt32(word);
			}
		}
	}
	,__class__: mnsl_spirv_MNSLSPIRVPrinter
});
var mnsl_spirv_MNSLSPIRVScope = function(variables,swizzlePointers) {
	this.swizzlePointers = new haxe_ds_IntMap();
	this.variables = new haxe_ds_StringMap();
	if(variables != null) {
		this.variables = variables;
	}
	if(swizzlePointers != null) {
		this.swizzlePointers = swizzlePointers;
	}
};
mnsl_spirv_MNSLSPIRVScope.__name__ = true;
mnsl_spirv_MNSLSPIRVScope.prototype = {
	copy: function() {
		return new mnsl_spirv_MNSLSPIRVScope(haxe_ds_StringMap.createCopy(this.variables.h),this.swizzlePointers.copy());
	}
	,setVariable: function(name,id) {
		this.variables.h[name] = { id : id, isParam : false};
	}
	,setParameter: function(name,id) {
		this.variables.h[name] = { id : id, isParam : true};
	}
	,getVariable: function(name) {
		return this.variables.h[name];
	}
	,hasVariable: function(name) {
		return Object.prototype.hasOwnProperty.call(this.variables.h,name);
	}
	,setSwizzlePointer: function(basePtr,components,vectorType) {
		this.swizzlePointers.h[basePtr] = { basePtr : basePtr, components : components, vectorType : vectorType};
	}
	,getSwizzlePointer: function(basePtr) {
		return this.swizzlePointers.h[basePtr];
	}
	,hasSwizzlePointer: function(basePtr) {
		return this.swizzlePointers.h.hasOwnProperty(basePtr);
	}
	,__class__: mnsl_spirv_MNSLSPIRVScope
};
var mnsl_tokenizer_MNSLToken = $hxEnums["mnsl.tokenizer.MNSLToken"] = { __ename__:true,__constructs__:null
	,None: {_hx_name:"None",_hx_index:0,__enum__:"mnsl.tokenizer.MNSLToken",toString:$estr}
	,At: ($_=function(info) { return {_hx_index:1,info:info,__enum__:"mnsl.tokenizer.MNSLToken",toString:$estr}; },$_._hx_name="At",$_.__params__ = ["info"],$_)
	,Identifier: ($_=function(value,info) { return {_hx_index:2,value:value,info:info,__enum__:"mnsl.tokenizer.MNSLToken",toString:$estr}; },$_._hx_name="Identifier",$_.__params__ = ["value","info"],$_)
	,IntegerLiteral: ($_=function(value,info) { return {_hx_index:3,value:value,info:info,__enum__:"mnsl.tokenizer.MNSLToken",toString:$estr}; },$_._hx_name="IntegerLiteral",$_.__params__ = ["value","info"],$_)
	,FloatLiteral: ($_=function(value,info) { return {_hx_index:4,value:value,info:info,__enum__:"mnsl.tokenizer.MNSLToken",toString:$estr}; },$_._hx_name="FloatLiteral",$_.__params__ = ["value","info"],$_)
	,StringLiteral: ($_=function(value,info) { return {_hx_index:5,value:value,info:info,__enum__:"mnsl.tokenizer.MNSLToken",toString:$estr}; },$_._hx_name="StringLiteral",$_.__params__ = ["value","info"],$_)
	,LeftParen: ($_=function(info) { return {_hx_index:6,info:info,__enum__:"mnsl.tokenizer.MNSLToken",toString:$estr}; },$_._hx_name="LeftParen",$_.__params__ = ["info"],$_)
	,RightParen: ($_=function(info) { return {_hx_index:7,info:info,__enum__:"mnsl.tokenizer.MNSLToken",toString:$estr}; },$_._hx_name="RightParen",$_.__params__ = ["info"],$_)
	,LeftBracket: ($_=function(info) { return {_hx_index:8,info:info,__enum__:"mnsl.tokenizer.MNSLToken",toString:$estr}; },$_._hx_name="LeftBracket",$_.__params__ = ["info"],$_)
	,RightBracket: ($_=function(info) { return {_hx_index:9,info:info,__enum__:"mnsl.tokenizer.MNSLToken",toString:$estr}; },$_._hx_name="RightBracket",$_.__params__ = ["info"],$_)
	,LeftBrace: ($_=function(info) { return {_hx_index:10,info:info,__enum__:"mnsl.tokenizer.MNSLToken",toString:$estr}; },$_._hx_name="LeftBrace",$_.__params__ = ["info"],$_)
	,RightBrace: ($_=function(info) { return {_hx_index:11,info:info,__enum__:"mnsl.tokenizer.MNSLToken",toString:$estr}; },$_._hx_name="RightBrace",$_.__params__ = ["info"],$_)
	,Comma: ($_=function(info) { return {_hx_index:12,info:info,__enum__:"mnsl.tokenizer.MNSLToken",toString:$estr}; },$_._hx_name="Comma",$_.__params__ = ["info"],$_)
	,Dot: ($_=function(info) { return {_hx_index:13,info:info,__enum__:"mnsl.tokenizer.MNSLToken",toString:$estr}; },$_._hx_name="Dot",$_.__params__ = ["info"],$_)
	,Minus: ($_=function(info) { return {_hx_index:14,info:info,__enum__:"mnsl.tokenizer.MNSLToken",toString:$estr}; },$_._hx_name="Minus",$_.__params__ = ["info"],$_)
	,Plus: ($_=function(info) { return {_hx_index:15,info:info,__enum__:"mnsl.tokenizer.MNSLToken",toString:$estr}; },$_._hx_name="Plus",$_.__params__ = ["info"],$_)
	,Semicolon: ($_=function(info) { return {_hx_index:16,info:info,__enum__:"mnsl.tokenizer.MNSLToken",toString:$estr}; },$_._hx_name="Semicolon",$_.__params__ = ["info"],$_)
	,Slash: ($_=function(info) { return {_hx_index:17,info:info,__enum__:"mnsl.tokenizer.MNSLToken",toString:$estr}; },$_._hx_name="Slash",$_.__params__ = ["info"],$_)
	,Star: ($_=function(info) { return {_hx_index:18,info:info,__enum__:"mnsl.tokenizer.MNSLToken",toString:$estr}; },$_._hx_name="Star",$_.__params__ = ["info"],$_)
	,Percent: ($_=function(info) { return {_hx_index:19,info:info,__enum__:"mnsl.tokenizer.MNSLToken",toString:$estr}; },$_._hx_name="Percent",$_.__params__ = ["info"],$_)
	,Question: ($_=function(info) { return {_hx_index:20,info:info,__enum__:"mnsl.tokenizer.MNSLToken",toString:$estr}; },$_._hx_name="Question",$_.__params__ = ["info"],$_)
	,Assign: ($_=function(info) { return {_hx_index:21,info:info,__enum__:"mnsl.tokenizer.MNSLToken",toString:$estr}; },$_._hx_name="Assign",$_.__params__ = ["info"],$_)
	,Equal: ($_=function(info) { return {_hx_index:22,info:info,__enum__:"mnsl.tokenizer.MNSLToken",toString:$estr}; },$_._hx_name="Equal",$_.__params__ = ["info"],$_)
	,Colon: ($_=function(info) { return {_hx_index:23,info:info,__enum__:"mnsl.tokenizer.MNSLToken",toString:$estr}; },$_._hx_name="Colon",$_.__params__ = ["info"],$_)
	,Spread: ($_=function(info) { return {_hx_index:24,info:info,__enum__:"mnsl.tokenizer.MNSLToken",toString:$estr}; },$_._hx_name="Spread",$_.__params__ = ["info"],$_)
	,And: ($_=function(info) { return {_hx_index:25,info:info,__enum__:"mnsl.tokenizer.MNSLToken",toString:$estr}; },$_._hx_name="And",$_.__params__ = ["info"],$_)
	,Or: ($_=function(info) { return {_hx_index:26,info:info,__enum__:"mnsl.tokenizer.MNSLToken",toString:$estr}; },$_._hx_name="Or",$_.__params__ = ["info"],$_)
	,Less: ($_=function(info) { return {_hx_index:27,info:info,__enum__:"mnsl.tokenizer.MNSLToken",toString:$estr}; },$_._hx_name="Less",$_.__params__ = ["info"],$_)
	,Greater: ($_=function(info) { return {_hx_index:28,info:info,__enum__:"mnsl.tokenizer.MNSLToken",toString:$estr}; },$_._hx_name="Greater",$_.__params__ = ["info"],$_)
	,LessEqual: ($_=function(info) { return {_hx_index:29,info:info,__enum__:"mnsl.tokenizer.MNSLToken",toString:$estr}; },$_._hx_name="LessEqual",$_.__params__ = ["info"],$_)
	,GreaterEqual: ($_=function(info) { return {_hx_index:30,info:info,__enum__:"mnsl.tokenizer.MNSLToken",toString:$estr}; },$_._hx_name="GreaterEqual",$_.__params__ = ["info"],$_)
	,NotEqual: ($_=function(info) { return {_hx_index:31,info:info,__enum__:"mnsl.tokenizer.MNSLToken",toString:$estr}; },$_._hx_name="NotEqual",$_.__params__ = ["info"],$_)
	,Not: ($_=function(info) { return {_hx_index:32,info:info,__enum__:"mnsl.tokenizer.MNSLToken",toString:$estr}; },$_._hx_name="Not",$_.__params__ = ["info"],$_)
};
mnsl_tokenizer_MNSLToken.__constructs__ = [mnsl_tokenizer_MNSLToken.None,mnsl_tokenizer_MNSLToken.At,mnsl_tokenizer_MNSLToken.Identifier,mnsl_tokenizer_MNSLToken.IntegerLiteral,mnsl_tokenizer_MNSLToken.FloatLiteral,mnsl_tokenizer_MNSLToken.StringLiteral,mnsl_tokenizer_MNSLToken.LeftParen,mnsl_tokenizer_MNSLToken.RightParen,mnsl_tokenizer_MNSLToken.LeftBracket,mnsl_tokenizer_MNSLToken.RightBracket,mnsl_tokenizer_MNSLToken.LeftBrace,mnsl_tokenizer_MNSLToken.RightBrace,mnsl_tokenizer_MNSLToken.Comma,mnsl_tokenizer_MNSLToken.Dot,mnsl_tokenizer_MNSLToken.Minus,mnsl_tokenizer_MNSLToken.Plus,mnsl_tokenizer_MNSLToken.Semicolon,mnsl_tokenizer_MNSLToken.Slash,mnsl_tokenizer_MNSLToken.Star,mnsl_tokenizer_MNSLToken.Percent,mnsl_tokenizer_MNSLToken.Question,mnsl_tokenizer_MNSLToken.Assign,mnsl_tokenizer_MNSLToken.Equal,mnsl_tokenizer_MNSLToken.Colon,mnsl_tokenizer_MNSLToken.Spread,mnsl_tokenizer_MNSLToken.And,mnsl_tokenizer_MNSLToken.Or,mnsl_tokenizer_MNSLToken.Less,mnsl_tokenizer_MNSLToken.Greater,mnsl_tokenizer_MNSLToken.LessEqual,mnsl_tokenizer_MNSLToken.GreaterEqual,mnsl_tokenizer_MNSLToken.NotEqual,mnsl_tokenizer_MNSLToken.Not];
var mnsl_tokenizer_MNSLTokenInfo = function(line,column,position,length) {
	this.length = 1;
	this.position = 0;
	this.column = 0;
	this.line = 0;
	if(line != null) {
		this.line = line;
	}
	if(column != null) {
		this.column = column;
	}
	if(position != null) {
		this.position = position;
	}
	if(length != null) {
		this.length = length;
	}
};
mnsl_tokenizer_MNSLTokenInfo.__name__ = true;
mnsl_tokenizer_MNSLTokenInfo.prototype = {
	toString: function() {
		return this.line + ":" + this.column + " ";
	}
	,__class__: mnsl_tokenizer_MNSLTokenInfo
};
var mnsl_tokenizer_MNSLTokenizer = function(context,source,defines) {
	this.source = StringTools.replace(StringTools.replace(source,"\r\n","\n"),"\r","\n");
	this.position = 0;
	this.length = source.length;
	this.context = context;
	this.defines = defines;
};
mnsl_tokenizer_MNSLTokenizer.__name__ = true;
mnsl_tokenizer_MNSLTokenizer.prototype = {
	run: function() {
		var tokens = [];
		var line = 1;
		var column = 0;
		var skipActive = false;
		var condActive = false;
		var condResult = true;
		var appendToken = function(token) {
			if(!skipActive) {
				tokens.push(token);
			}
		};
		while(this.position < this.length) {
			var char = this.source.charAt(this.position);
			var initialPosition = this.position;
			switch(char) {
			case "\t":
				column += 4;
				this.position++;
				break;
			case "\n":
				++line;
				column = 0;
				this.position++;
				break;
			case " ":
				++column;
				this.position++;
				break;
			case "!":
				if(this.source.charAt(this.position + 1) == "=") {
					appendToken(mnsl_tokenizer_MNSLToken.NotEqual(new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,2)));
					this.position += 2;
					column += 2;
				} else {
					appendToken(mnsl_tokenizer_MNSLToken.Not(new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,1)));
					this.position++;
					++column;
				}
				break;
			case "\"":
				var start = this.position;
				this.position++;
				++column;
				while(this.position < this.length && this.source.charAt(this.position) != "\"") {
					if(this.source.charAt(this.position) == "\\") {
						this.position++;
						++column;
					}
					this.position++;
					++column;
				}
				this.position++;
				++column;
				if(this.position < this.length) {
					appendToken(mnsl_tokenizer_MNSLToken.StringLiteral(HxOverrides.substr(this.source,start + 1,this.position - start - 2),new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,this.position - start)));
				} else {
					this.context.emitError(mnsl_MNSLError.TokenizerUnterminatedString(new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,this.position - start)));
				}
				break;
			case "#":
				this.position++;
				++column;
				var cmd = "";
				while(this.position < this.length && this.isLetter(HxOverrides.cca(this.source,this.position))) {
					cmd += this.source.charAt(this.position);
					this.position++;
					++column;
				}
				cmd = cmd.toLowerCase();
				var args = [];
				while(this.position < this.length && this.source.charAt(this.position) != "\n") if(this.source.charAt(this.position) == " ") {
					this.position++;
					++column;
				} else {
					var arg = "";
					while(this.position < this.length && this.source.charAt(this.position) != " " && this.source.charAt(this.position) != "\n") {
						if(this.source.charAt(this.position) == "\"" || this.source.charAt(this.position) == "'") {
							this.position++;
							++column;
							continue;
						}
						arg += this.source.charAt(this.position);
						this.position++;
						++column;
					}
					args.push(arg);
				}
				this.position++;
				column = 0;
				++line;
				if(cmd == "if") {
					if(args.length == 0) {
						this.context.emitError(mnsl_MNSLError.TokenizerPreprocessorError("Missing condition for #if directive",new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,this.position - initialPosition)));
					} else {
						var condition = args.join(" ");
						if(StringTools.startsWith(condition,"!")) {
							condResult = !Object.prototype.hasOwnProperty.call(this.defines.h,HxOverrides.substr(condition,1,null));
						} else {
							condResult = Object.prototype.hasOwnProperty.call(this.defines.h,condition);
						}
						skipActive = !condResult;
						condActive = true;
					}
				} else if(cmd == "else" && condActive) {
					skipActive = condResult;
				} else if(cmd == "end") {
					skipActive = false;
					condActive = false;
				} else if(cmd == "include" && !skipActive) {
					var sourceStr = this.context.getOptions().preprocessorIncludeFunc(args[0],this.context.getOptions().rootPath);
					if(sourceStr == null) {
						this.context.emitError(mnsl_MNSLError.TokenizerPreprocessorError("Failed to include file: " + args[0],new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,this.position - initialPosition)));
					} else {
						var tokenizer = new mnsl_tokenizer_MNSLTokenizer(this.context,sourceStr,this.defines);
						var includedTokens = tokenizer.run();
						var _g = 0;
						while(_g < includedTokens.length) {
							var token = includedTokens[_g];
							++_g;
							appendToken(token);
						}
					}
				} else {
					this.context.emitError(mnsl_MNSLError.TokenizerPreprocessorError("Unknown or invalid preprocessor command: #" + cmd,new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,this.position - initialPosition)));
				}
				break;
			case "%":
				appendToken(mnsl_tokenizer_MNSLToken.Percent(new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,1)));
				this.position++;
				++column;
				break;
			case "&":
				if(this.source.charAt(this.position + 1) == "&") {
					appendToken(mnsl_tokenizer_MNSLToken.And(new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,2)));
					this.position += 2;
					column += 2;
				} else {
					appendToken(mnsl_tokenizer_MNSLToken.And(new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,1)));
					this.position++;
					++column;
				}
				break;
			case "'":
				var start1 = this.position;
				this.position++;
				++column;
				while(this.position < this.length && this.source.charAt(this.position) != "'") {
					if(this.source.charAt(this.position) == "\\") {
						this.position++;
						++column;
					}
					this.position++;
					++column;
				}
				this.position++;
				++column;
				if(this.position < this.length) {
					appendToken(mnsl_tokenizer_MNSLToken.StringLiteral(HxOverrides.substr(this.source,start1 + 1,this.position - start1 - 1),new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,this.position - start1)));
				} else {
					this.context.emitError(mnsl_MNSLError.TokenizerUnterminatedString(new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,this.position - start1)));
				}
				break;
			case "(":
				appendToken(mnsl_tokenizer_MNSLToken.LeftParen(new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,1)));
				this.position++;
				++column;
				break;
			case ")":
				appendToken(mnsl_tokenizer_MNSLToken.RightParen(new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,1)));
				this.position++;
				++column;
				break;
			case "*":
				appendToken(mnsl_tokenizer_MNSLToken.Star(new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,1)));
				this.position++;
				++column;
				break;
			case "+":
				appendToken(mnsl_tokenizer_MNSLToken.Plus(new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,1)));
				this.position++;
				++column;
				if(this.source.charAt(this.position) == "+") {
					appendToken(mnsl_tokenizer_MNSLToken.Assign(new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,2)));
					appendToken(mnsl_tokenizer_MNSLToken.IntegerLiteral("1",new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,1)));
					this.position++;
					++column;
				}
				break;
			case ",":
				appendToken(mnsl_tokenizer_MNSLToken.Comma(new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,1)));
				this.position++;
				++column;
				break;
			case "-":
				appendToken(mnsl_tokenizer_MNSLToken.Minus(new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,1)));
				this.position++;
				++column;
				if(this.source.charAt(this.position) == "-") {
					appendToken(mnsl_tokenizer_MNSLToken.Assign(new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,2)));
					appendToken(mnsl_tokenizer_MNSLToken.IntegerLiteral("1",new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,1)));
					this.position++;
					++column;
				}
				break;
			case ".":
				if(this.source.charAt(this.position + 1) == "." && this.source.charAt(this.position + 2) == ".") {
					appendToken(mnsl_tokenizer_MNSLToken.Spread(new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,3)));
					this.position += 3;
					column += 3;
				} else {
					appendToken(mnsl_tokenizer_MNSLToken.Dot(new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,1)));
					this.position++;
					++column;
				}
				break;
			case "/":
				if(this.source.charAt(this.position + 1) == "/") {
					while(this.position < this.length && this.source.charAt(this.position) != "\n") {
						this.position++;
						++column;
					}
				} else {
					appendToken(mnsl_tokenizer_MNSLToken.Slash(new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,1)));
					this.position++;
					++column;
				}
				break;
			case ":":
				appendToken(mnsl_tokenizer_MNSLToken.Colon(new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,1)));
				this.position++;
				++column;
				break;
			case ";":
				appendToken(mnsl_tokenizer_MNSLToken.Semicolon(new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,1)));
				this.position++;
				++column;
				break;
			case "<":
				if(this.source.charAt(this.position + 1) == "=") {
					appendToken(mnsl_tokenizer_MNSLToken.LessEqual(new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,2)));
					this.position += 2;
					column += 2;
				} else {
					appendToken(mnsl_tokenizer_MNSLToken.Less(new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,1)));
					this.position++;
					++column;
				}
				break;
			case "=":
				if(this.source.charAt(this.position + 1) == "=") {
					appendToken(mnsl_tokenizer_MNSLToken.Equal(new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,2)));
					this.position += 2;
					column += 2;
				} else {
					appendToken(mnsl_tokenizer_MNSLToken.Assign(new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,1)));
					this.position++;
					++column;
				}
				break;
			case ">":
				if(this.source.charAt(this.position + 1) == "=") {
					appendToken(mnsl_tokenizer_MNSLToken.GreaterEqual(new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,2)));
					this.position += 2;
					column += 2;
				} else {
					appendToken(mnsl_tokenizer_MNSLToken.Greater(new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,1)));
					this.position++;
					++column;
				}
				break;
			case "?":
				appendToken(mnsl_tokenizer_MNSLToken.Question(new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,1)));
				this.position++;
				++column;
				break;
			case "@":
				appendToken(mnsl_tokenizer_MNSLToken.At(new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,1)));
				this.position++;
				++column;
				break;
			case "[":
				appendToken(mnsl_tokenizer_MNSLToken.LeftBracket(new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,1)));
				this.position++;
				++column;
				break;
			case "]":
				appendToken(mnsl_tokenizer_MNSLToken.RightBracket(new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,1)));
				this.position++;
				++column;
				break;
			case "{":
				appendToken(mnsl_tokenizer_MNSLToken.LeftBrace(new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,1)));
				this.position++;
				++column;
				break;
			case "|":
				if(this.source.charAt(this.position + 1) == "|") {
					appendToken(mnsl_tokenizer_MNSLToken.Or(new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,2)));
					this.position += 2;
					column += 2;
				} else {
					appendToken(mnsl_tokenizer_MNSLToken.Or(new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,1)));
					this.position++;
					++column;
				}
				break;
			case "}":
				appendToken(mnsl_tokenizer_MNSLToken.RightBrace(new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,1)));
				this.position++;
				++column;
				break;
			default:
				var charCode = HxOverrides.cca(char,0);
				if(charCode >= 48 && charCode <= 57) {
					var start2 = this.position;
					var hasDot = false;
					while(this.position < this.length && (this.isDigit(HxOverrides.cca(this.source,this.position)) || !hasDot && this.source.charAt(this.position) == ".")) {
						if(this.source.charAt(this.position) == ".") {
							hasDot = true;
						}
						this.position++;
						++column;
					}
					var value = HxOverrides.substr(this.source,start2,this.position - start2);
					if(hasDot) {
						appendToken(mnsl_tokenizer_MNSLToken.FloatLiteral(value,new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,this.position - start2)));
					} else {
						appendToken(mnsl_tokenizer_MNSLToken.IntegerLiteral(value,new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,this.position - start2)));
					}
				} else if(charCode >= 65 && charCode <= 90 || charCode >= 97 && charCode <= 122 || charCode == 95) {
					var start3 = this.position;
					while(this.position < this.length && (this.isLetter(HxOverrides.cca(this.source,this.position)) || this.isDigit(HxOverrides.cca(this.source,this.position)) || this.source.charAt(this.position) == "_")) {
						this.position++;
						++column;
					}
					var value1 = HxOverrides.substr(this.source,start3,this.position - start3);
					var nextChar = this.position < this.length ? this.source.charAt(this.position) : null;
					var secondChar = this.position + 1 < this.length ? this.source.charAt(this.position + 1) : null;
					if(nextChar == "[" && secondChar == "]") {
						value1 = "Array<" + value1 + ", -1>";
						this.position += 2;
						column += 2;
					}
					appendToken(mnsl_tokenizer_MNSLToken.Identifier(value1,new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,this.position - start3)));
				} else {
					this.position++;
					++column;
					if(charCode == null) {
						continue;
					}
					this.context.emitError(mnsl_MNSLError.TokenizerInvalidChar(charCode,new mnsl_tokenizer_MNSLTokenInfo(line,column,initialPosition,1)));
				}
			}
		}
		return tokens;
	}
	,isDigit: function(charCode) {
		if(charCode >= 48) {
			return charCode <= 57;
		} else {
			return false;
		}
	}
	,isLetter: function(charCode) {
		if(!(charCode >= 65 && charCode <= 90)) {
			if(charCode >= 97) {
				return charCode <= 122;
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	,__class__: mnsl_tokenizer_MNSLTokenizer
};
function $getIterator(o) { if( o instanceof Array ) return new haxe_iterators_ArrayIterator(o); else return o.iterator(); }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
Object.defineProperty(String.prototype,"__class__",{ value : String, enumerable : false, writable : true});
String.__name__ = true;
Array.__name__ = true;
var Int = { };
var Dynamic = { };
var Float = Number;
var Bool = Boolean;
var Class = { };
var Enum = { };
js_Boot.__toStr = ({ }).toString;
haxe_io_FPHelper.helper = new DataView(new ArrayBuffer(8));
Demo.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
